// This file was generated by the Owl parsing tool.
// Make sure to #define OWL_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define OWL_PARSER_IMPLEMENTATION
//   #include "parser.h"

#ifndef OWL_PARSER_H
#define OWL_PARSER_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The owl_tree struct represents an entire parse tree.  Use the
// owl_tree_create_...() functions to create a tree, then call owl_tree_root()
// to get the root owl_ref.
struct owl_tree;

// Creates an owl_tree from a string.  The tree may directly reference pieces of
// the string -- you're responsible for keeping it around until
// owl_tree_destroy() is called.
struct owl_tree *owl_tree_create_from_string(const char *string);

// Creates an owl_tree by reading from a file.
struct owl_tree *owl_tree_create_from_file(FILE *file);

// Explicitly create a tree with particular options.
struct owl_tree_options {
    // Exactly one of string or file should be set.
    const char *string;
    FILE *file;
};
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options);

// Destroys an owl_tree, freeing its resources back to the system.
void owl_tree_destroy(struct owl_tree *);

// Prints a representation of the tree to standard output.
void owl_tree_print(struct owl_tree *);

// An owl_ref references a list of children in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// child into its appropriate parsed_... struct.
struct owl_ref {
    struct owl_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The owl_next function advances a ref to the next sibling element.
struct owl_ref owl_next(struct owl_ref);

// Tests two refs for equality.
bool owl_refs_equal(struct owl_ref a, struct owl_ref b);

// Returns the root owl_ref.
struct owl_ref owl_tree_root_ref(struct owl_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root ref.
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum owl_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to owl_tree_create_from_file was NULL.
    ERROR_INVALID_FILE,

    // The options passed to owl_tree_create_with_options weren't valid --
    // both file and string were specified at the same time or neither were.
    ERROR_INVALID_OPTIONS,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_EXACT = 1,
    PARSED_IDENT,
    PARSED_RANGE,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_AT_LEAST,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_REPETITION,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct source_range range;
    struct owl_ref rule;
    struct owl_ref comment_token;
    struct owl_ref custom_token;
    struct owl_ref whitespace;
};

struct parsed_rule {
    struct source_range range;
    struct owl_ref identifier;
    struct owl_ref body;
};

struct parsed_body {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
    struct owl_ref operators;
};

struct parsed_operators {
    struct source_range range;
    struct owl_ref fixity;
    struct owl_ref operator;
};

struct parsed_fixity {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref assoc;
};

struct parsed_assoc {
    struct source_range range;
    enum parsed_type type;
};

struct parsed_operator {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
};

struct parsed_expr {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref identifier;
    struct owl_ref exception;
    struct owl_ref rename;
    struct owl_ref string;
    struct owl_ref expr;
    struct owl_ref begin_token;
    struct owl_ref end_token;
    struct owl_ref repetition;
    struct owl_ref operand;
};

struct parsed_repetition {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref begin;
    struct owl_ref end;
};

struct parsed_comment_token {
    struct source_range range;
    struct owl_ref string;
    struct owl_ref comment_token_v1;
};

struct parsed_comment_token_v1 {
    struct source_range range;
    struct owl_ref string;
};

struct parsed_custom_token {
    struct source_range range;
    struct owl_ref identifier;
    struct owl_ref string;
};

struct parsed_whitespace {
    struct source_range range;
    struct owl_ref string;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_string {
    struct source_range range;
    const char *string;
    size_t length;
};

struct parsed_integer {
    struct source_range range;
    uint64_t integer;
};

struct parsed_grammar parsed_grammar_get(struct owl_ref);
struct parsed_rule parsed_rule_get(struct owl_ref);
struct parsed_body parsed_body_get(struct owl_ref);
struct parsed_operators parsed_operators_get(struct owl_ref);
struct parsed_fixity parsed_fixity_get(struct owl_ref);
struct parsed_assoc parsed_assoc_get(struct owl_ref);
struct parsed_operator parsed_operator_get(struct owl_ref);
struct parsed_expr parsed_expr_get(struct owl_ref);
struct parsed_repetition parsed_repetition_get(struct owl_ref);
struct parsed_comment_token parsed_comment_token_get(struct owl_ref);
struct parsed_comment_token_v1 parsed_comment_token_v1_get(struct owl_ref);
struct parsed_custom_token parsed_custom_token_get(struct owl_ref);
struct parsed_whitespace parsed_whitespace_get(struct owl_ref);
struct parsed_identifier parsed_identifier_get(struct owl_ref);
struct parsed_string parsed_string_get(struct owl_ref);
struct parsed_integer parsed_integer_get(struct owl_ref);

#endif

#ifdef OWL_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(__clang__) || defined(__GNUC__)
#define OWL_DONT_INLINE __attribute__((noinline))
#else
#define OWL_DONT_INLINE
#endif

struct owl_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum owl_error error;
    struct source_range error_range;
    size_t root_offset;
    size_t next_identifier_token_offset;
    size_t next_string_token_offset;
    size_t next_integer_token_offset;
};
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct owl_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct owl_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct owl_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 0) {
        return (struct parsed_grammar){
            .rule.empty = true,
            .comment_token.empty = true,
            .custom_token.empty = true,
            .whitespace.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_grammar result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.rule._tree = ref._tree;
    result.rule._offset = read_tree(&offset, ref._tree);
    result.rule._type = 1;
    result.rule.empty = result.rule._offset == 0;
    result.comment_token._tree = ref._tree;
    result.comment_token._offset = read_tree(&offset, ref._tree);
    result.comment_token._type = 9;
    result.comment_token.empty = result.comment_token._offset == 0;
    result.custom_token._tree = ref._tree;
    result.custom_token._offset = read_tree(&offset, ref._tree);
    result.custom_token._type = 11;
    result.custom_token.empty = result.custom_token._offset == 0;
    result.whitespace._tree = ref._tree;
    result.whitespace._offset = read_tree(&offset, ref._tree);
    result.whitespace._type = 12;
    result.whitespace.empty = result.whitespace._offset == 0;
    return result;
}
struct parsed_rule parsed_rule_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 1) {
        return (struct parsed_rule){
            .identifier.empty = true,
            .body.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_rule result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 13;
    result.identifier.empty = result.identifier._offset == 0;
    result.body._tree = ref._tree;
    result.body._offset = read_tree(&offset, ref._tree);
    result.body._type = 2;
    result.body.empty = result.body._offset == 0;
    return result;
}
struct parsed_body parsed_body_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 2) {
        return (struct parsed_body){
            .expr.empty = true,
            .identifier.empty = true,
            .operators.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_body result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 13;
    result.identifier.empty = result.identifier._offset == 0;
    result.operators._tree = ref._tree;
    result.operators._offset = read_tree(&offset, ref._tree);
    result.operators._type = 3;
    result.operators.empty = result.operators._offset == 0;
    return result;
}
struct parsed_operators parsed_operators_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 3) {
        return (struct parsed_operators){
            .fixity.empty = true,
            .operator.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operators result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.fixity._tree = ref._tree;
    result.fixity._offset = read_tree(&offset, ref._tree);
    result.fixity._type = 4;
    result.fixity.empty = result.fixity._offset == 0;
    result.operator._tree = ref._tree;
    result.operator._offset = read_tree(&offset, ref._tree);
    result.operator._type = 6;
    result.operator.empty = result.operator._offset == 0;
    return result;
}
struct parsed_fixity parsed_fixity_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 4) {
        return (struct parsed_fixity){
            .assoc.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_fixity result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.assoc._tree = ref._tree;
    result.assoc._offset = read_tree(&offset, ref._tree);
    result.assoc._type = 5;
    result.assoc.empty = result.assoc._offset == 0;
    return result;
}
struct parsed_assoc parsed_assoc_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 5) {
        return (struct parsed_assoc){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_assoc result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    return result;
}
struct parsed_operator parsed_operator_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 6) {
        return (struct parsed_operator){
            .expr.empty = true,
            .identifier.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operator result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 13;
    result.identifier.empty = result.identifier._offset == 0;
    return result;
}
struct parsed_expr parsed_expr_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 7) {
        return (struct parsed_expr){
            .identifier.empty = true,
            .exception.empty = true,
            .rename.empty = true,
            .string.empty = true,
            .expr.empty = true,
            .begin_token.empty = true,
            .end_token.empty = true,
            .repetition.empty = true,
            .operand.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_expr result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 13;
    result.identifier.empty = result.identifier._offset == 0;
    result.exception._tree = ref._tree;
    result.exception._offset = read_tree(&offset, ref._tree);
    result.exception._type = 13;
    result.exception.empty = result.exception._offset == 0;
    result.rename._tree = ref._tree;
    result.rename._offset = read_tree(&offset, ref._tree);
    result.rename._type = 13;
    result.rename.empty = result.rename._offset == 0;
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 14;
    result.string.empty = result.string._offset == 0;
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.begin_token._tree = ref._tree;
    result.begin_token._offset = read_tree(&offset, ref._tree);
    result.begin_token._type = 14;
    result.begin_token.empty = result.begin_token._offset == 0;
    result.end_token._tree = ref._tree;
    result.end_token._offset = read_tree(&offset, ref._tree);
    result.end_token._type = 14;
    result.end_token.empty = result.end_token._offset == 0;
    result.repetition._tree = ref._tree;
    result.repetition._offset = read_tree(&offset, ref._tree);
    result.repetition._type = 8;
    result.repetition.empty = result.repetition._offset == 0;
    result.operand._tree = ref._tree;
    result.operand._offset = read_tree(&offset, ref._tree);
    result.operand._type = 7;
    result.operand.empty = result.operand._offset == 0;
    return result;
}
struct parsed_repetition parsed_repetition_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 8) {
        return (struct parsed_repetition){
            .begin.empty = true,
            .end.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_repetition result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.begin._tree = ref._tree;
    result.begin._offset = read_tree(&offset, ref._tree);
    result.begin._type = 15;
    result.begin.empty = result.begin._offset == 0;
    result.end._tree = ref._tree;
    result.end._offset = read_tree(&offset, ref._tree);
    result.end._type = 15;
    result.end.empty = result.end._offset == 0;
    return result;
}
struct parsed_comment_token parsed_comment_token_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 9) {
        return (struct parsed_comment_token){
            .string.empty = true,
            .comment_token_v1.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_comment_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 14;
    result.string.empty = result.string._offset == 0;
    result.comment_token_v1._tree = ref._tree;
    result.comment_token_v1._offset = read_tree(&offset, ref._tree);
    result.comment_token_v1._type = 10;
    result.comment_token_v1.empty = result.comment_token_v1._offset == 0;
    return result;
}
struct parsed_comment_token_v1 parsed_comment_token_v1_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 10) {
        return (struct parsed_comment_token_v1){
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_comment_token_v1 result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 14;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_custom_token parsed_custom_token_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 11) {
        return (struct parsed_custom_token){
            .identifier.empty = true,
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_custom_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 13;
    result.identifier.empty = result.identifier._offset == 0;
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 14;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_whitespace parsed_whitespace_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 12) {
        return (struct parsed_whitespace){
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_whitespace result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 14;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 13) {
        return (struct parsed_identifier){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_identifier result = {
        .range.start = start_location,
        .range.end = end_location,
        .identifier = ref._tree->string + start_location,
        .length = end_location - start_location,
    };
    return result;
}
struct parsed_string parsed_string_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 14) {
        return (struct parsed_string){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    size_t string_offset = read_tree(&token_offset, ref._tree);
    const char *string = string_offset ?
     (const char *)ref._tree->parse_tree + string_offset : ref._tree->string + start_location + 1;
    size_t string_length = string_offset ?
     read_tree(&token_offset, ref._tree) : end_location - start_location - 2;
    struct parsed_string result = {
        .range.start = start_location,
        .range.end = end_location,
        .string = string,
        .length = string_length,
    };
    return result;
}
struct parsed_integer parsed_integer_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 15) {
        return (struct parsed_integer){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_integer result = {
        .range.start = start_location,
        .range.end = end_location,
        .integer = read_tree(&token_offset, ref._tree),
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    write_tree(tree, start_location);
    write_tree(tree, end_location - start_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 4: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 5: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 6: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_REPETITION);
            break;
        case 8:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 9:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        write_tree(tree, slots[8]);
        break;
    }
    case 8: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_EXACT);
            break;
        case 1:
            write_tree(tree, PARSED_AT_LEAST);
            break;
        case 2:
            write_tree(tree, PARSED_RANGE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 9: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 10: {
        write_tree(tree, slots[0]);
        break;
    }
    case 11: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 12: {
        write_tree(tree, slots[0]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    switch (rule) {
    case 13: {
        size_t offset13 = tree->next_identifier_token_offset;
        if (offset13 == 0)
            abort();
        write_tree(tree, offset13);
        tree->next_identifier_token_offset = offset13;
        tree->next_identifier_token_offset -= read_tree(&offset13, tree);
        break;
    }
    case 14: {
        size_t offset14 = tree->next_string_token_offset;
        if (offset14 == 0)
            abort();
        write_tree(tree, offset14);
        tree->next_string_token_offset = offset14;
        tree->next_string_token_offset -= read_tree(&offset14, tree);
        break;
    }
    case 15: {
        size_t offset15 = tree->next_integer_token_offset;
        if (offset15 == 0)
            abort();
        write_tree(tree, offset15);
        tree->next_integer_token_offset = offset15;
        tree->next_integer_token_offset -= read_tree(&offset15, tree);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct owl_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_OPTIONS:
        fprintf(stderr, "invalid options\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_repetition_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_comment_token_v1_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_custom_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_whitespace_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_integer_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_grammar it = parsed_grammar_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        parsed_custom_token_print(tree, it.custom_token, "custom_token", indent + 1);
        parsed_whitespace_print(tree, it.whitespace, "whitespace", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_rule it = parsed_rule_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_body it = parsed_body_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_operators it = parsed_operators_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_fixity it = parsed_fixity_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_assoc it = parsed_assoc_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_operator it = parsed_operator_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_expr it = parsed_expr_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_REPETITION:
            printf(" : REPETITION");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_repetition_print(tree, it.repetition, "repetition", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_repetition_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_repetition it = parsed_repetition_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("repetition");
        if (strcmp("repetition", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_EXACT:
            printf(" : EXACT");
            break;
        case PARSED_AT_LEAST:
            printf(" : AT_LEAST");
            break;
        case PARSED_RANGE:
            printf(" : RANGE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_integer_print(tree, it.begin, "begin", indent + 1);
        parsed_integer_print(tree, it.end, "end", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_comment_token it = parsed_comment_token_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_comment_token_v1_print(tree, it.comment_token_v1, "comment_token_v1", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_comment_token_v1_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_comment_token_v1 it = parsed_comment_token_v1_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("comment_token_v1");
        if (strcmp("comment_token_v1", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_custom_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_custom_token it = parsed_custom_token_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("custom_token");
        if (strcmp("custom_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_whitespace_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_whitespace it = parsed_whitespace_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("whitespace");
        if (strcmp("whitespace", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_identifier it = parsed_identifier_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_string it = parsed_string_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_integer_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_integer it = parsed_integer_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("integer");
        if (strcmp("integer", slot_name))
            printf("@%s", slot_name);
        printf(" - %" PRIu64, it.integer);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
void owl_tree_print(struct owl_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, owl_tree_root_ref(tree), "grammar", 0);
}
struct owl_ref owl_next(struct owl_ref ref) {
    if (ref.empty) return ref;
    size_t offset = ref._offset;
    size_t delta = read_tree(&ref._offset, ref._tree);
    return (struct owl_ref){
        ._tree = ref._tree,
        ._offset = offset - delta,
        ._type = ref._type,
        .empty = delta == 0,
    };
}
bool owl_refs_equal(struct owl_ref a, struct owl_ref b) {
    return a._tree == b._tree && a._offset == b._offset;
}
struct owl_ref owl_tree_root_ref(struct owl_tree *tree) {
    check_for_error(tree);
    return (struct owl_ref){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(owl_tree_root_ref(tree));
}
#define ESCAPE_CHAR(c, info) ((c) == 'b' ? '\b' : (c) == 'f' ? '\f' : (c) == 'n' ? '\n' : (c) == 'r' ? '\r' : (c) == 't' ? '\t' : (c))
#define IGNORE_TOKEN_WRITE(...)
#define IGNORE_TOKEN_READ(...) (0)
#define CUSTOM_TOKEN_DATA(...)
#define IF_IDENTIFIER_TOKEN(cond, ...) if (cond) __VA_ARGS__
#define INTEGER_TOKEN_DATA(name) uint64_t name
#define IF_INTEGER_TOKEN(cond, ...) if (cond) __VA_ARGS__
#define NUMBER_TOKEN_DATA(...)
#define IF_NUMBER_TOKEN(...) if (0) { /* no number tokens */  }
#define STRING_TOKEN_HAS_ESCAPES(name) bool name = false
#define IF_STRING_TOKEN(cond, ...) if (cond) __VA_ARGS__
static size_t read_whitespace(const char *text, void *info);
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_identifier_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    tree->next_identifier_token_offset = token_offset;
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct owl_tree *tree = info;
    size_t string_offset = has_escapes ? (uint8_t *)string - tree->parse_tree : 0;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_string_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    if (string_offset) {
        write_tree(tree, string_offset);
        write_tree(tree, string_length);
    } else
        write_tree(tree, 0);
    tree->next_string_token_offset = token_offset;
}
static void write_integer_token(size_t offset, size_t length, uint64_t integer, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_integer_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    write_tree(tree, integer);
    tree->next_integer_token_offset = token_offset;
}
static void *allocate_string_contents(size_t size, void *info) {
    struct owl_tree *tree = info;
    if (tree->next_offset + size > tree->parse_tree_size)
        grow_tree(tree, tree->next_offset + size);
    void *p = tree->parse_tree + tree->next_offset;
    tree->next_offset += size;
    return p;
}
struct owl_token_run {
    struct owl_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct owl_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_is_hexadecimal_alpha(char c) {
    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool char_ends_identifier(char c) {
    return c != '-';
}
static bool encode_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct owl_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct owl_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool OWL_DONT_INLINE owl_default_tokenizer_advance(struct owl_default_tokenizer *tokenizer, struct owl_token_run **previous_run) {
    struct owl_token_run *run = malloc(sizeof(struct owl_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        size_t whitespace_length = read_whitespace(text + offset, tokenizer->info);
        if (whitespace_length > 0) {
            whitespace += whitespace_length;
            offset += whitespace_length;
            continue;
        }
        uint32_t token = -1;
        CUSTOM_TOKEN_DATA(custom_data);
        uint64_t integer = 0;
        NUMBER_TOKEN_DATA(number);
        STRING_TOKEN_HAS_ESCAPES(has_escapes);
        bool is_token = false;
        bool end_token = false;
        bool custom_token = false;
        bool comment = false;
        bool custom_whitespace = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 4294967295U) comment = true;
        }
        if (IGNORE_TOKEN_READ(&token, &token_length, text + offset, &custom_whitespace, &custom_data, tokenizer->info)) {
            is_token = true;
            custom_token = true;
            end_token = false;
            comment = false;
        }
        IF_INTEGER_TOKEN(char_is_numeric(c), {
            size_t integer_offset = offset;
            uint64_t base = 10;
            if (c == '0' && (text[offset + 1] == 'x' || text[offset + 1] == 'X') && (char_is_numeric(text[offset + 2]) || char_is_hexadecimal_alpha(text[integer_offset + 2]))) {
                integer_offset = offset + 2;
                base = 16;
            }
            integer = 0;
            bool overflow = false;
            while (char_is_numeric(text[integer_offset]) || (base == 16 && char_is_hexadecimal_alpha(text[integer_offset]))) {
                uint64_t last = integer;
                integer *= base;
                uint64_t ch = text[integer_offset];
                if (ch >= '0' && ch <= '9') integer += ch - '0';
                else if (ch >= 'a' && ch <= 'f') integer += ch - 'a' + 0xa;
                else if (ch >= 'A' && ch <= 'F') integer += ch - 'A' + 0xA;
                if (integer < last) {
                    overflow = true;
                    break;
                }
                integer_offset++;
            }
            if (!overflow && integer_offset - offset > token_length) {
                token_length = integer_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 29;
            }
        }
        ) IF_NUMBER_TOKEN(char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1])), {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 4294967295U;
            }
        }
        ) else IF_STRING_TOKEN(c == '\'' || c == '"', {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    custom_whitespace = false;
                    token = 28;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        ) else IF_IDENTIFIER_TOKEN(char_starts_identifier(c), {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            while (!char_ends_identifier(text[identifier_offset - 1])) identifier_offset--;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 27;
            }
        }
        ) if (custom_whitespace) {
            whitespace += token_length;
            offset += token_length;
            continue;
        }
        else if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 4294967295U) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 27) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 29) {
            write_integer_token(offset, token_length, integer, tokenizer->info);
        }
        else if (token == 4294967295U) {
            IGNORE_TOKEN_WRITE(offset, token_length, number, tokenizer->info);
        }
        else IF_STRING_TOKEN(token == 28, {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                size_t i;
                for (i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = allocate_string_contents(string_length, tokenizer->info);
                size_t j = 0;
                for (i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = ESCAPE_CHAR(text[content_offset + i], tokenizer->info);
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        ) else if (custom_token) {
            IGNORE_TOKEN_WRITE(offset, token_length, token, custom_data, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    uint16_t j;
    for (j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (number_of_slots > 0 && !node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity = 0;
            int precedence = 0;
            do {
                int local = 0;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_continuation;
struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
    struct fill_run_continuation *cont;
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    size_t top_index;
    size_t capacity;
    int error;
};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0);
static void (*state_funcs[129])(struct owl_token_run *, struct fill_run_state *, uint16_t);
static void state_func_105(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(0 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    default: top->cont->error = 1; return;
    }
}
static void state_func_5(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 6; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_118(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 30;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_108(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 32;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_18(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 21; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_73(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 31;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_35(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 38; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_59(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 62; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_19(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 20; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_21(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 22; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_11(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 23; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_36(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 37; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_38(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 39; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_51(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 57; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_60(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 61; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_62(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 63; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_3(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 65; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_2(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 28: top->state = 67; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_1(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 28: top->state = 68; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_124(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 127; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_125(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 126; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_127(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 128; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_92(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 95; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_89(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 73; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_93(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 94; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_95(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 96; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_82(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 29: top->state = 85; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_87(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 29: top->state = 88; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_90(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 29: top->state = 91; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_109(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 112; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_110(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 111; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_112(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 113; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_71(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 28: top->state = 97; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_24(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 40; return;
    case 4: top->state = 41; return;
    case 5: top->state = 42; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_85(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 17: top->state = 86; return;
    case 19: top->state = 87; return;
    case 21: top->state = 73; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_76(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 17: top->state = 89; return;
    case 19: top->state = 90; return;
    case 21: top->state = 73; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_69(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(7 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 12: top->state = 70; return;
    case 14: top->state = 71; return;
    case 20: top->state = 72; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_42(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 6: top->state = 43; return;
    case 7: top->state = 44; return;
    case 8: top->state = 45; return;
    case 9: top->state = 46; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_6(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 7; return;
    case 28: top->state = 8; return;
    case 30: top->state = 9; return;
    case 32: top->state = 10; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_32(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 33; return;
    case 28: top->state = 26; return;
    case 30: top->state = 27; return;
    case 32: top->state = 28; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_40(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 47; return;
    case 28: top->state = 48; return;
    case 30: top->state = 49; return;
    case 32: top->state = 50; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_70(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 114; return;
    case 28: top->state = 115; return;
    case 30: top->state = 116; return;
    case 32: top->state = 117; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_83(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 74; return;
    case 28: top->state = 75; return;
    case 30: top->state = 77; return;
    case 32: top->state = 78; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_97(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 27: top->state = 98; return;
    case 28: top->state = 99; return;
    case 30: top->state = 100; return;
    case 32: top->state = 101; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_67(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 5; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_64(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 5; return;
    case 28: top->state = 64; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_65(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 5; return;
    case 28: top->state = 66; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_72(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 73; return;
    case 27: top->state = 74; return;
    case 28: top->state = 75; return;
    case 29: top->state = 76; return;
    case 30: top->state = 77; return;
    case 32: top->state = 78; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_23(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 24; return;
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 25; return;
    case 28: top->state = 26; return;
    case 30: top->state = 27; return;
    case 32: top->state = 28; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_57(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 24; return;
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 58; return;
    case 28: top->state = 48; return;
    case 30: top->state = 49; return;
    case 32: top->state = 50; return;
    default:
        bracket_entry_state(run, top, token_index, 5);
        return;
    }
}
static void state_func_107(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 16: top->state = 102; return;
    case 17: top->state = 103; return;
    case 18: top->state = 104; return;
    case 22: top->state = 105; return;
    case 27: top->state = 98; return;
    case 28: top->state = 106; return;
    case 30: top->state = 100; return;
    case 31: top->state = 107; return;
    case 32: top->state = 101; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_30(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 11; return;
    case 16: top->state = 29; return;
    case 17: top->state = 30; return;
    case 18: top->state = 31; return;
    case 22: top->state = 32; return;
    case 27: top->state = 33; return;
    case 28: top->state = 26; return;
    case 30: top->state = 27; return;
    case 31: top->state = 34; return;
    case 32: top->state = 28; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_48(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 51; return;
    case 16: top->state = 52; return;
    case 17: top->state = 53; return;
    case 18: top->state = 54; return;
    case 22: top->state = 55; return;
    case 27: top->state = 47; return;
    case 28: top->state = 48; return;
    case 30: top->state = 49; return;
    case 31: top->state = 56; return;
    case 32: top->state = 50; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_115(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 13: top->state = 118; return;
    case 16: top->state = 119; return;
    case 17: top->state = 120; return;
    case 18: top->state = 121; return;
    case 22: top->state = 122; return;
    case 27: top->state = 114; return;
    case 28: top->state = 115; return;
    case 30: top->state = 116; return;
    case 31: top->state = 123; return;
    case 32: top->state = 117; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_99(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 15: top->state = 108; return;
    case 16: top->state = 102; return;
    case 17: top->state = 103; return;
    case 18: top->state = 104; return;
    case 22: top->state = 105; return;
    case 27: top->state = 98; return;
    case 28: top->state = 106; return;
    case 30: top->state = 100; return;
    case 31: top->state = 107; return;
    case 32: top->state = 101; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_75(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 16: top->state = 79; return;
    case 17: top->state = 80; return;
    case 18: top->state = 81; return;
    case 19: top->state = 82; return;
    case 21: top->state = 73; return;
    case 22: top->state = 83; return;
    case 27: top->state = 74; return;
    case 28: top->state = 75; return;
    case 30: top->state = 77; return;
    case 31: top->state = 84; return;
    case 32: top->state = 78; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_98(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(4 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 109; return;
    case 11: top->state = 110; return;
    case 16: top->state = 102; return;
    case 17: top->state = 103; return;
    case 18: top->state = 104; return;
    case 22: top->state = 105; return;
    case 27: top->state = 98; return;
    case 28: top->state = 106; return;
    case 30: top->state = 100; return;
    case 31: top->state = 107; return;
    case 32: top->state = 101; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_39(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 11; return;
    case 10: top->state = 35; return;
    case 11: top->state = 36; return;
    case 16: top->state = 29; return;
    case 17: top->state = 30; return;
    case 18: top->state = 31; return;
    case 22: top->state = 32; return;
    case 27: top->state = 33; return;
    case 28: top->state = 26; return;
    case 30: top->state = 27; return;
    case 31: top->state = 34; return;
    case 32: top->state = 28; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_47(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 51; return;
    case 10: top->state = 59; return;
    case 11: top->state = 60; return;
    case 16: top->state = 52; return;
    case 17: top->state = 53; return;
    case 18: top->state = 54; return;
    case 22: top->state = 55; return;
    case 27: top->state = 47; return;
    case 28: top->state = 48; return;
    case 30: top->state = 49; return;
    case 31: top->state = 56; return;
    case 32: top->state = 50; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_128(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 124; return;
    case 11: top->state = 125; return;
    case 13: top->state = 118; return;
    case 16: top->state = 119; return;
    case 17: top->state = 120; return;
    case 18: top->state = 121; return;
    case 22: top->state = 122; return;
    case 27: top->state = 114; return;
    case 28: top->state = 115; return;
    case 30: top->state = 116; return;
    case 31: top->state = 123; return;
    case 32: top->state = 117; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_25(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 6; return;
    case 1: top->state = 11; return;
    case 10: top->state = 35; return;
    case 11: top->state = 36; return;
    case 16: top->state = 29; return;
    case 17: top->state = 30; return;
    case 18: top->state = 31; return;
    case 22: top->state = 32; return;
    case 27: top->state = 33; return;
    case 28: top->state = 26; return;
    case 30: top->state = 27; return;
    case 31: top->state = 34; return;
    case 32: top->state = 28; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_58(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 6; return;
    case 1: top->state = 51; return;
    case 10: top->state = 59; return;
    case 11: top->state = 60; return;
    case 16: top->state = 52; return;
    case 17: top->state = 53; return;
    case 18: top->state = 54; return;
    case 22: top->state = 55; return;
    case 27: top->state = 47; return;
    case 28: top->state = 48; return;
    case 30: top->state = 49; return;
    case 31: top->state = 56; return;
    case 32: top->state = 50; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_74(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 92; return;
    case 11: top->state = 93; return;
    case 16: top->state = 79; return;
    case 17: top->state = 80; return;
    case 18: top->state = 81; return;
    case 19: top->state = 82; return;
    case 21: top->state = 73; return;
    case 22: top->state = 83; return;
    case 27: top->state = 74; return;
    case 28: top->state = 75; return;
    case 30: top->state = 77; return;
    case 31: top->state = 84; return;
    case 32: top->state = 78; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_14(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 11; return;
    case 16: top->state = 12; return;
    case 17: top->state = 13; return;
    case 18: top->state = 14; return;
    case 22: top->state = 15; return;
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 16; return;
    case 28: top->state = 8; return;
    case 30: top->state = 9; return;
    case 31: top->state = 17; return;
    case 32: top->state = 10; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_22(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 11; return;
    case 10: top->state = 18; return;
    case 11: top->state = 19; return;
    case 16: top->state = 12; return;
    case 17: top->state = 13; return;
    case 18: top->state = 14; return;
    case 22: top->state = 15; return;
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 16; return;
    case 28: top->state = 8; return;
    case 30: top->state = 9; return;
    case 31: top->state = 17; return;
    case 32: top->state = 10; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void state_func_16(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 6; return;
    case 1: top->state = 11; return;
    case 10: top->state = 18; return;
    case 11: top->state = 19; return;
    case 16: top->state = 12; return;
    case 17: top->state = 13; return;
    case 18: top->state = 14; return;
    case 22: top->state = 15; return;
    case 23: top->state = 1; return;
    case 24: top->state = 2; return;
    case 25: top->state = 3; return;
    case 26: top->state = 4; return;
    case 27: top->state = 16; return;
    case 28: top->state = 8; return;
    case 30: top->state = 9; return;
    case 31: top->state = 17; return;
    case 32: top->state = 10; return;
    default:
        bracket_entry_state(run, top, token_index, 7);
        return;
    }
}
static void (*state_funcs[129])(struct owl_token_run *, struct fill_run_state *, uint16_t) = {
    state_func_67, state_func_1, state_func_2, state_func_3,
    state_func_64, state_func_5, state_func_6, state_func_22,
    state_func_14, state_func_14, state_func_14, state_func_11,
    state_func_14, state_func_14, state_func_14, state_func_6,
    state_func_16, state_func_14, state_func_18, state_func_19,
    state_func_14, state_func_21, state_func_22, state_func_23,
    state_func_24, state_func_25, state_func_30, state_func_30,
    state_func_30, state_func_30, state_func_30, state_func_30,
    state_func_32, state_func_39, state_func_30, state_func_35,
    state_func_36, state_func_30, state_func_38, state_func_39,
    state_func_40, state_func_40, state_func_42, state_func_40,
    state_func_40, state_func_40, state_func_40, state_func_47,
    state_func_48, state_func_48, state_func_48, state_func_51,
    state_func_48, state_func_48, state_func_48, state_func_40,
    state_func_48, state_func_57, state_func_58, state_func_59,
    state_func_60, state_func_48, state_func_62, state_func_47,
    state_func_64, state_func_65, state_func_65, state_func_67,
    state_func_67, state_func_69, state_func_70, state_func_71,
    state_func_72, state_func_73, state_func_74, state_func_75,
    state_func_76, state_func_75, state_func_75, state_func_75,
    state_func_75, state_func_75, state_func_82, state_func_83,
    state_func_75, state_func_85, state_func_89, state_func_87,
    state_func_89, state_func_89, state_func_90, state_func_89,
    state_func_92, state_func_93, state_func_75, state_func_95,
    state_func_74, state_func_97, state_func_98, state_func_99,
    state_func_107, state_func_107, state_func_107, state_func_107,
    state_func_107, state_func_105, state_func_99, state_func_107,
    state_func_108, state_func_109, state_func_110, state_func_107,
    state_func_112, state_func_98, state_func_128, state_func_115,
    state_func_115, state_func_115, state_func_118, state_func_115,
    state_func_115, state_func_115, state_func_70, state_func_115,
    state_func_124, state_func_125, state_func_115, state_func_127,
    state_func_128,};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0) {
    struct fill_run_continuation *cont = top->cont;
    cont->top_index++;
    if (cont->top_index >= cont->capacity) {
        size_t new_capacity = (cont->capacity + 2) * 3 / 2;
        if (new_capacity <= cont->capacity)
            abort();
        struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
        if (!new_states)
            abort();
        cont->stack = new_states;
        cont->capacity = new_capacity;
        top = &cont->stack[cont->top_index];
    } else
        top++;
    top->cont = cont;
    top->reachability_mask[0] = mask0;
    run->states[token_index] = 69;
    state_func_69(run, top, token_index);
    if (top->cont->error == -1)
        top->cont->error = 1;
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct owl_default_tokenizer *, struct owl_token_run *, struct owl_tree *);

static struct owl_tree *owl_tree_create_empty(void) {
    return calloc(1, sizeof(struct owl_tree));
}

static void free_token_runs(struct owl_token_run **run) {
    while (*run) {
        struct owl_token_run *prev = (*run)->prev;
        free(*run);
        *run = prev;
    }
}
static void parse_string(struct owl_tree *tree, const char *string) {
    tree->string = string;
    tree->next_offset = 1;
    struct owl_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct owl_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .top_index = 0,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    c.stack[0].cont = &c;
    uint16_t failing_index = 0;
    while (owl_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            free_token_runs(&token_run);
            return;
        }
    }
    struct fill_run_state top = c.stack[c.top_index];
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    switch (top.state) {
    case 0:
    case 4:
    case 7:
    case 8:
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 22:
    case 23:
    case 57:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
}
static struct owl_tree *owl_tree_create_with_error(enum owl_error e) {
    struct owl_tree *tree = owl_tree_create_empty();
    tree->error = e;
    return tree;
}
struct owl_tree *owl_tree_create_from_string(const char *string) {
    return owl_tree_create_with_options((struct owl_tree_options){ .string = string });
}
struct owl_tree *owl_tree_create_from_file(FILE *file) {
    if (!file)
        return owl_tree_create_with_error(ERROR_INVALID_FILE);
    return owl_tree_create_with_options((struct owl_tree_options){ .file = file });
}
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options) {
    if (!options.file == !options.string)
        return owl_tree_create_with_error(ERROR_INVALID_OPTIONS);
    if (options.file) {
        char *str = 0;
        size_t len = 32;
        size_t off = 0;
        while (true) {
            len = len * 3 / 2;
            char *s = realloc(str, len);
            if (!s) {
                free(str);
                return 0;
            }
            str = s;
            off += fread(str + off, 1, len - off, options.file);
            if (off < len) {
                str[off] = '\0';
                break;
            }
        }
        options.string = str;
    }
    struct owl_tree *tree = owl_tree_create_empty();
    if (options.file)
        tree->owns_string = true;
    parse_string(tree, options.string);
    return tree;
}
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void owl_tree_destroy(struct owl_tree *tree) {
    if (!tree)
        return;
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree);
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    while (token_index < number_of_tokens) {
        struct fill_run_state *top = &cont->stack[cont->top_index];
        run->states[token_index] = top->state;
        state_funcs[top->state](run, top, token_index);
        if (cont->error) {
            *failing_index = token_index - (cont->error > 0 ? 0 : 1);
            return false;
        }
        token_index++;
    }
    return true;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,4096,0,4096,4096,32768,32769,16385,0,4096,4096,32768,32769,32770,32769,16385,0,4096,4096,32768,32769,36864,40960,16384,0,4096,
4096,32768,32769,36864,40960,16385,0,4096,4096,32768,32769,36864,40960,16386,0,4096,4096,32768,32769,36864,40961,16387,0,4096,4096,32768,32769,36864,40962,0,
4096,4096,32768,32769,36864,40963,0,4096,4096,32768,32769,36864,45060,0,4096,4096,32768,32769,36864,45061,0,4096,4096,32768,32769,36864,45062,0,4096,4096,
32768,32769,36864,45063,0,4096,4096,32769,16384,0,4096,4096,32769,32769,16384,0,4096,4096,32770,16384,0,4096,4096,32770,16385,0,4096,4096,32771,0,
4096,4096,32771,16384,0,4096,16385,0,4096,32768,32769,16385,0,4096,32768,32769,32770,32769,16385,0,4096,32768,32769,36864,40960,16384,0,4096,32768,32769,
36864,40960,16385,0,4096,32768,32769,36864,40960,16386,0,4096,32768,32769,36864,40961,16387,0,4096,32768,32769,36864,40962,0,4096,32768,32769,36864,40963,0,
4096,32768,32769,36864,45060,0,4096,32768,32769,36864,45061,0,4096,32768,32769,36864,45062,0,4096,32768,32769,36864,45063,0,4096,32769,16384,0,4096,32769,
32769,16384,0,4096,32770,16384,0,4096,32770,16385,0,4096,32770,32769,16385,0,4096,32771,0,4096,32771,16384,0,16384,0,16385,0,16389,0,16390,
0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,0,20480,8192,
4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,0,20480,8192,
16385,0,20480,8192,16389,0,20480,45064,24576,40960,16384,0,20480,45064,24576,40960,16385,0,20480,45064,24576,40960,16386,0,20480,45064,24576,40961,16387,0,
20480,45064,24576,40962,0,20480,45064,24576,40963,0,20480,45064,24576,45060,0,20480,45064,24576,45061,0,20480,45064,24576,45062,0,20480,45064,24576,45063,0,
20480,45065,0,24576,40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,
0,24576,45062,0,24576,45063,0,32768,32769,16385,0,32768,32769,32770,32769,16385,0,32768,32769,36864,40960,16384,0,32768,32769,36864,40960,16385,0,32768,
32769,36864,40960,16386,0,32768,32769,36864,40961,16387,0,32768,32769,36864,40962,0,32768,32769,36864,40963,0,32768,32769,36864,45060,0,32768,32769,36864,45061,
0,32768,32769,36864,45062,0,32768,32769,36864,45063,0,32769,16384,0,32769,32769,16384,0,32770,16384,0,32770,16385,0,32771,0,32771,16384,0,32775,
12288,16384,0,32775,12289,0,32775,12290,16385,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,0,36864,
40963,0,36864,45060,0,36864,45061,0,36864,45062,0,36864,45063,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,
36868,40962,0,36868,40963,0,36868,45060,0,36868,45061,0,36868,45062,0,36868,45063,0,};
static const uint8_t action_table[1024][4][7] = {
{{238,144,125,13,174,40,14,},{220,104,124,13,42,198,13,},{212,228,112,206,220,5,0,},},{{9,30,92,207,0,0,0,},{207,228,104,207,136,3,0,},},{{6,34,4,221,0,0,0,},
{5,238,69,5,18,6,0,},{221,64,108,213,168,7,0,},},{{5,250,69,5,18,6,0,},{3,54,69,3,18,6,0,},{238,144,129,38,126,8,14,},},{{18,46,109,215,164,3,0,},
{206,224,124,13,142,69,13,},},{{220,108,124,13,42,198,13,},{216,248,73,5,122,5,0,},{216,220,125,13,142,85,32,},},{{10,234,108,206,164,3,0,},{214,92,108,214,200,4,0,},
{212,208,64,212,4,6,0,},},{{5,2,110,216,172,5,0,},{208,64,124,13,34,167,13,},{206,196,124,13,142,69,13,},},{{15,150,108,214,164,3,0,},{226,160,125,13,42,38,14,},
{220,124,124,13,42,198,13,},},{{17,202,109,216,164,3,0,},{4,206,109,216,48,8,0,},{210,64,104,207,104,7,0,},{208,24,120,21,190,86,13,},},{{12,34,108,207,164,3,0,},
{5,2,126,13,42,86,32,},{216,236,65,5,82,5,0,},},{{9,2,93,207,0,0,0,},{212,216,128,38,250,229,12,},},{{224,148,65,226,80,5,0,},{217,128,128,38,246,103,13,},
{206,212,88,212,160,5,0,},},{{218,56,128,38,250,85,13,},{210,8,113,27,94,7,0,},{210,88,64,218,228,6,0,},},{{12,18,108,207,164,3,0,},{4,2,114,216,96,8,0,},
{224,156,129,38,62,5,14,},},{{5,206,113,216,220,5,0,},{215,52,65,3,82,5,0,},{213,28,64,218,80,5,0,},},{{3,70,109,215,172,5,0,},{217,104,120,21,234,103,13,},
{208,0,104,207,104,7,0,},},{{4,230,69,5,150,8,0,},{212,188,124,13,42,70,13,},{206,184,128,38,62,229,12,},},{{220,128,108,214,172,5,0,},{217,116,112,214,216,7,0,},},
{{209,52,104,207,208,1,0,},},{{3,62,69,3,18,6,0,},{226,192,109,55,190,5,0,},{216,208,73,5,122,5,0,},},{{29,30,40,14,2,0,0,},{3,122,69,3,18,6,0,},
{226,132,109,224,172,5,0,},{213,52,128,38,62,85,13,},},{{220,112,108,214,172,5,0,},{218,28,72,218,28,6,0,},{209,68,124,13,98,161,13,},},{{226,152,73,226,28,6,0,},
{209,60,112,213,180,0,0,},},{{3,46,69,3,18,6,0,},{211,164,108,206,168,7,0,},{206,168,36,42,114,4,0,},},{{238,148,125,13,174,40,14,},{224,160,65,226,80,5,0,},
{208,60,108,213,92,6,0,},},{{214,148,72,220,120,5,0,},{206,244,128,38,62,229,12,},},{{218,88,120,21,238,85,13,},},{{21,206,53,4,2,0,0,},{9,14,93,207,0,0,0,},
{226,148,73,226,28,6,0,},},{{226,172,69,226,16,6,0,},{212,232,72,212,28,6,0,},},{{215,80,129,38,62,117,13,},{207,44,108,6,2,2,0,},},{{220,104,64,220,4,6,0,},},
{{5,254,109,40,190,5,0,},{221,80,112,213,216,7,0,},{215,40,65,3,82,5,0,},},{{214,108,72,220,120,5,0,},},{{22,122,77,34,9,0,0,},{11,6,101,207,0,0,0,},
{210,68,64,218,228,6,0,},{208,28,112,213,164,6,0,},},{{3,58,73,3,30,6,0,},{218,40,72,218,28,6,0,},{211,208,124,13,38,72,13,},},{{213,68,68,218,100,5,0,},
{209,24,120,21,214,80,13,},},{{13,50,85,23,2,0,0,},{34,61,65,3,138,8,0,},{221,32,68,218,12,8,0,},},{{218,32,68,218,16,6,0,},{210,92,104,207,104,7,0,},
{208,28,72,218,12,7,0,},},{{218,56,72,218,28,6,0,},{207,52,128,38,186,82,13,},},{{13,70,85,34,1,0,0,},{224,196,129,38,62,5,14,},{221,40,72,218,24,8,0,},
{209,76,108,28,150,0,0,},},{{5,210,69,5,18,6,0,},{221,48,68,218,12,8,0,},{217,100,112,214,216,7,0,},},{{34,61,121,21,114,120,13,},{210,40,124,13,34,167,13,},},
{{8,42,96,209,0,0,0,},{211,244,64,212,0,8,0,},{206,208,128,38,62,229,12,},},{{24,234,44,10,2,0,0,},{221,56,72,218,24,8,0,},{213,40,120,21,42,85,13,},},
{{224,152,73,226,120,5,0,},{206,188,68,212,100,5,0,},},{{212,244,120,21,238,229,12,},{211,172,120,21,234,231,12,},},{{5,226,109,216,172,5,0,},{210,56,72,218,12,7,0,},},
{{238,156,113,224,96,8,0,},{220,116,64,220,4,6,0,},{213,48,112,213,16,5,0,},},{{206,252,68,212,100,5,0,},},{{238,152,125,13,174,40,14,},{210,48,68,218,248,6,0,},
{208,68,72,218,12,7,0,},},{{212,192,120,21,238,229,12,},},{{216,0,70,5,102,5,0,},{213,56,72,218,120,5,0,},{210,48,72,218,12,7,0,},},{{16,174,109,224,164,3,0,},
{218,24,128,38,250,85,13,},{208,68,128,38,210,86,13,},},{{6,158,4,217,0,0,0,},{206,232,124,13,142,69,13,},},{{17,210,109,216,164,3,0,},{220,100,124,13,42,198,13,},
{210,12,108,11,82,7,0,},},{{27,10,113,27,174,3,0,},{207,84,108,44,78,2,0,},{207,32,104,207,136,3,0,},},{{224,172,129,38,62,5,14,},},{{226,168,125,13,42,38,14,},
{224,188,113,224,16,5,0,},{215,40,113,215,16,5,0,},},{{210,28,108,213,92,6,0,},},{{12,10,109,207,164,3,0,},{7,14,105,207,0,0,0,},},{{12,42,108,207,164,3,0,},
{218,80,124,13,42,166,13,},{214,112,64,220,80,5,0,},},{{238,184,109,39,82,8,0,},{224,132,121,21,42,5,14,},{214,152,108,41,226,4,0,},},{{224,140,69,226,100,5,0,},
{210,64,112,213,164,6,0,},},{{5,2,130,38,250,133,13,},{216,236,73,5,122,5,0,},{213,64,128,38,62,85,13,},{211,208,68,212,12,8,0,},},{{13,66,85,34,1,0,0,},
{4,214,121,21,114,136,13,},{226,140,121,21,238,5,14,},},{{217,120,128,38,246,103,13,},{215,68,73,3,122,5,0,},{206,212,64,212,80,5,0,},},{{214,136,88,220,160,5,0,},
{210,88,120,21,190,86,13,},},{{218,68,124,13,42,166,13,},{209,68,128,38,242,80,13,},},{{4,250,69,5,150,8,0,},{213,28,72,218,120,5,0,},{211,240,108,24,202,7,0,},},
{{216,0,74,5,122,5,0,},{214,100,64,220,80,5,0,},},{{51,114,5,33,2,0,0,},{226,140,109,224,172,5,0,},{214,116,68,220,100,5,0,},},{{38,170,61,19,2,0,0,},
{213,88,88,218,160,5,0,},{213,64,0,12,210,3,0,},},{{220,132,68,220,16,6,0,},{211,224,108,206,168,7,0,},},{{5,222,69,5,18,6,0,},{238,144,109,224,48,8,0,},
{206,196,112,206,16,5,0,},},{{238,156,125,13,174,40,14,},{214,100,128,38,62,101,13,},{208,52,108,213,92,6,0,},},{{23,94,117,50,154,7,0,},{218,28,64,218,4,6,0,},},
{{215,64,109,215,200,4,0,},{209,60,120,21,214,80,13,},},{{5,210,121,21,238,133,13,},{221,64,120,21,234,87,13,},{206,168,28,42,50,4,0,},},{{34,65,113,215,96,8,0,},
{208,64,120,21,190,86,13,},{206,244,68,212,100,5,0,},},{{220,120,124,13,42,198,13,},{212,224,68,212,16,6,0,},},{{8,2,96,209,0,0,0,},{211,200,68,212,12,8,0,},
{208,40,64,218,228,6,0,},},{{5,246,109,32,206,5,0,},{214,120,72,220,120,5,0,},{212,208,108,206,172,5,0,},},{{6,70,4,221,0,0,0,},{212,232,112,206,220,5,0,},
{210,28,124,13,34,167,13,},},{{4,210,69,5,150,8,0,},{207,64,72,218,0,3,0,},},{{220,104,72,220,28,6,0,},},{{0}},{{34,41,65,3,138,8,0,},{218,80,128,38,250,85,13,},
{208,80,124,13,34,167,13,},},{{238,192,109,55,66,8,0,},{210,68,72,218,12,7,0,},{208,28,120,21,190,86,13,},},{{218,40,64,218,4,6,0,},{213,68,128,38,62,85,13,},
{209,92,104,207,208,1,0,},},{{215,56,89,3,162,5,0,},{209,68,108,213,84,0,0,},},{{217,132,120,21,234,103,13,},{217,124,128,38,246,103,13,},{213,52,124,13,142,165,13,},},
{{4,202,125,13,174,88,32,},{216,232,109,216,200,4,0,},},{{220,156,108,214,172,5,0,},{218,56,64,218,4,6,0,},},{{4,226,129,38,126,136,13,},{221,40,112,213,216,7,0,},
{206,200,124,13,142,69,13,},},{{218,48,128,38,250,85,13,},{206,208,112,206,16,5,0,},},{{224,144,69,226,100,5,0,},{221,68,108,213,168,7,0,},{210,4,105,207,104,7,0,},},
{{6,102,4,217,0,0,0,},{218,48,120,21,238,85,13,},{211,244,72,212,24,8,0,},},{{218,68,68,218,16,6,0,},{209,48,72,218,68,1,0,},},{{224,152,113,224,16,5,0,},
{212,184,128,38,250,229,12,},{206,188,124,13,142,69,13,},},{{34,129,109,215,48,8,0,},{212,244,112,206,220,5,0,},{208,40,108,213,92,6,0,},},{{5,206,65,5,6,6,0,},
{4,226,65,5,138,8,0,},{210,56,64,218,228,6,0,},},{{209,56,112,213,180,0,0,},},{{7,30,104,207,0,0,0,},{3,42,125,13,42,54,32,},{217,92,112,214,216,7,0,},},
{{34,69,73,3,162,8,0,},{208,48,68,218,248,6,0,},{206,96,12,35,226,3,0,},},{{36,206,108,20,118,3,0,},{216,204,125,13,142,85,32,},{207,68,104,207,136,3,0,},},
{{218,68,64,218,4,6,0,},{211,160,112,206,216,7,0,},{209,32,120,21,214,80,13,},},{{21,222,53,4,2,0,0,},{207,68,128,38,186,82,13,},},{{226,144,125,13,42,38,14,},
{209,64,124,13,98,161,13,},},{{26,134,44,15,2,0,0,},{34,53,113,215,96,8,0,},{207,40,68,218,232,2,0,},},{{9,94,92,207,0,0,0,},{212,188,128,38,250,229,12,},},
{{212,244,68,212,16,6,0,},{208,40,104,207,104,7,0,},},{{15,118,108,214,164,3,0,},{224,188,121,21,42,5,14,},{206,224,108,206,200,4,0,},},{{19,142,113,238,188,3,0,},
{220,124,120,21,238,101,13,},{207,56,68,218,232,2,0,},},{{14,42,108,213,164,3,0,},{4,246,109,32,82,8,0,},{209,88,64,218,12,1,0,},},{{216,220,65,5,82,5,0,},
{212,228,128,38,250,229,12,},},{{34,41,121,21,114,120,13,},{224,132,113,224,16,5,0,},},{{6,126,4,217,0,0,0,},{34,41,113,215,96,8,0,},{214,116,108,214,200,4,0,},
{210,64,120,21,190,86,13,},},{{209,28,68,218,40,1,0,},},{{221,36,120,21,234,87,13,},{217,120,68,220,12,8,0,},{211,248,108,43,186,7,0,},},{{11,18,101,207,0,0,0,},
{217,136,120,21,234,103,13,},{206,212,72,212,120,5,0,},},{{20,218,4,211,0,0,0,},{214,108,68,220,100,5,0,},{210,88,112,213,164,6,0,},},{{218,52,112,213,220,5,0,},
{210,80,68,218,248,6,0,},{208,36,72,218,12,7,0,},},{{5,206,129,38,250,133,13,},{217,104,68,220,12,8,0,},{209,56,124,13,98,161,13,},},{{214,100,72,220,120,5,0,},
{210,36,64,218,228,6,0,},},{{212,188,108,206,172,5,0,},{207,0,105,207,136,3,0,},},{{10,202,108,206,164,3,0,},{213,36,108,213,200,4,0,},},{{211,180,112,206,216,7,0,},
{209,52,120,21,214,80,13,},},{{226,140,129,38,250,5,14,},{206,196,120,21,42,229,12,},},{{17,234,109,216,164,3,0,},{3,82,73,3,30,6,0,},{221,48,64,218,0,8,0,},
{208,8,105,207,104,7,0,},},{{220,112,124,13,42,198,13,},{207,64,64,218,208,2,0,},},{{213,52,88,218,160,5,0,},{211,216,124,13,38,72,13,},{206,176,128,38,62,229,12,},},
{{21,214,53,4,2,0,0,},{221,64,112,213,216,7,0,},{207,88,128,38,186,82,13,},},{{34,65,121,21,114,120,13,},{238,148,109,224,48,8,0,},{208,64,112,213,164,6,0,},},
{{5,222,109,216,172,5,0,},{207,88,104,207,136,3,0,},},{{12,54,108,207,164,3,0,},},{{4,226,69,5,150,8,0,},{214,156,72,220,120,5,0,},},{{13,34,85,47,2,0,0,},
{238,132,109,224,48,8,0,},{215,56,113,215,16,5,0,},{212,232,120,21,238,229,12,},},{{216,208,109,216,200,4,0,},{207,80,112,213,132,2,0,},},{{10,218,108,206,164,3,0,},
{210,16,104,207,104,7,0,},},{{217,148,68,220,12,8,0,},{209,16,112,7,226,1,0,},},{{5,202,109,216,172,5,0,},{214,156,68,220,100,5,0,},{208,88,72,218,12,7,0,},},
{{34,45,121,21,114,120,13,},{216,224,109,216,200,4,0,},{208,28,64,218,228,6,0,},},{{221,60,128,38,246,87,13,},},{{217,128,108,214,168,7,0,},},{{238,172,69,226,148,8,0,},
{217,132,112,214,216,7,0,},{214,112,72,220,120,5,0,},},{{30,158,40,15,2,0,0,},{238,172,109,224,48,8,0,},{210,12,105,207,104,7,0,},{207,52,68,218,232,2,0,},},
{{218,56,120,21,238,85,13,},{216,232,129,38,62,133,13,},{210,40,104,207,104,7,0,},},{{217,124,108,214,168,7,0,},{211,252,68,212,12,8,0,},{210,8,105,207,104,7,0,},},
{{18,70,109,215,164,3,0,},{206,208,120,21,42,229,12,},},{{220,100,112,214,220,5,0,},{208,32,108,213,92,6,0,},},{{6,54,4,221,0,0,0,},{218,64,128,38,250,85,13,},},
{{10,178,108,206,164,3,0,},{215,116,109,34,250,4,0,},{209,48,64,218,12,1,0,},},{{226,136,129,38,250,5,14,},{224,152,121,21,42,5,14,},{206,200,112,206,16,5,0,},},
{{206,192,68,212,100,5,0,},},{{220,116,124,13,42,198,13,},{207,24,108,213,48,2,0,},},{{7,82,104,207,0,0,0,},{206,172,128,38,62,229,12,},},{{21,210,53,4,2,0,0,},
{5,234,109,216,172,5,0,},{217,92,120,21,234,103,13,},{216,248,129,38,62,133,13,},},{{34,69,113,215,96,8,0,},{208,68,120,21,190,86,13,},{208,48,124,13,34,167,13,},},
{{19,134,113,54,190,3,0,},{218,60,120,21,238,85,13,},{207,68,112,213,132,2,0,},},{{7,66,104,207,0,0,0,},{218,68,72,218,28,6,0,},{211,160,120,21,234,231,12,},
{209,32,112,213,180,0,0,},},{{238,144,73,226,160,8,0,},{220,92,108,214,172,5,0,},{206,164,108,206,200,4,0,},},{{15,126,108,214,164,3,0,},{206,232,108,206,200,4,0,},},
{{213,80,68,218,100,5,0,},{207,40,124,13,26,163,13,},},{{220,100,128,38,250,101,13,},{215,40,109,215,200,4,0,},},{{209,80,68,218,40,1,0,},{206,232,128,38,62,229,12,},},
{{220,108,64,220,4,6,0,},{214,128,120,21,42,101,13,},{214,112,68,220,100,5,0,},},{{7,90,104,207,0,0,0,},{208,16,104,207,104,7,0,},},{{3,70,69,3,18,6,0,},
{209,88,72,218,68,1,0,},},{{226,196,113,224,220,5,0,},{209,64,68,218,40,1,0,},},{{20,202,4,211,0,0,0,},{224,140,129,38,62,5,14,},{217,112,72,220,24,8,0,},
{206,200,88,212,160,5,0,},},{{216,24,113,216,16,5,0,},},{{238,188,73,226,160,8,0,},{238,152,65,226,136,8,0,},},{{16,142,109,224,164,3,0,},{221,36,112,213,216,7,0,},
{213,20,0,12,210,3,0,},},{{13,62,85,34,1,0,0,},{224,192,109,55,226,4,0,},{217,136,64,220,0,8,0,},{206,212,112,206,16,5,0,},},{{238,168,73,226,160,8,0,},
{210,88,104,207,104,7,0,},{210,44,108,6,54,6,0,},},{{34,57,69,3,150,8,0,},{218,52,120,21,238,85,13,},{208,36,64,218,228,6,0,},},{{16,158,109,224,164,3,0,},
{7,70,104,207,0,0,0,},{211,200,112,206,216,7,0,},},{{224,156,113,224,16,5,0,},{212,252,68,212,16,6,0,},},{{17,226,109,216,164,3,0,},{3,46,73,3,30,6,0,},
{208,0,105,207,104,7,0,},},{{8,54,96,209,0,0,0,},{208,16,105,207,104,7,0,},},{{220,128,128,38,250,101,13,},{211,180,120,21,234,231,12,},{209,52,112,213,180,0,0,},},
{{5,26,113,216,220,5,0,},{3,122,121,21,238,117,13,},{206,252,88,212,160,5,0,},},{{238,156,109,224,48,8,0,},{220,136,64,220,4,6,0,},{208,52,124,13,34,167,13,},},
{{55,182,5,31,2,0,0,},{207,28,68,218,232,2,0,},},{{211,172,112,206,216,7,0,},{210,0,113,7,114,7,0,},},{{3,46,109,215,172,5,0,},{34,121,109,215,48,8,0,},
{211,208,64,212,0,8,0,},},{{238,140,109,224,48,8,0,},{216,200,65,5,82,5,0,},{208,40,68,218,248,6,0,},},{{218,64,108,213,172,5,0,},{207,8,113,27,102,3,0,},},
{{14,54,108,213,164,3,0,},{216,208,129,38,62,133,13,},{215,80,125,13,142,53,32,},},{{224,188,129,38,62,5,14,},{206,228,128,38,62,229,12,},},{{226,172,109,224,172,5,0,},},
{{21,230,53,4,2,0,0,},{34,41,69,3,150,8,0,},{207,80,120,21,162,82,13,},},{{7,6,105,207,0,0,0,},{221,80,68,218,12,8,0,},{217,148,128,38,246,103,13,},
{211,192,108,206,168,7,0,},},{{21,238,53,4,2,0,0,},{221,88,112,213,216,7,0,},{209,16,104,207,208,1,0,},},{{238,188,125,13,174,40,14,},{208,88,112,213,164,6,0,},
{207,36,128,38,186,82,13,},},{{214,120,68,220,100,5,0,},{210,68,120,21,190,86,13,},{207,16,105,207,136,3,0,},},{{10,230,108,206,164,3,0,},{8,18,96,209,0,0,0,},
{215,32,109,215,200,4,0,},{214,144,108,26,250,4,0,},},{{226,188,73,226,28,6,0,},{217,116,108,214,168,7,0,},{214,124,72,220,120,5,0,},},{{18,78,109,215,164,3,0,},
{224,136,113,224,16,5,0,},{206,216,120,21,42,229,12,},},{{4,202,109,216,48,8,0,},{220,148,64,220,4,6,0,},{212,160,108,206,172,5,0,},{208,88,64,218,228,6,0,},},
{{4,238,109,216,48,8,0,},{218,56,112,213,220,5,0,},{213,24,108,213,200,4,0,},},{{238,160,121,21,114,8,14,},},{{34,45,65,3,138,8,0,},{212,196,108,206,172,5,0,},
{210,40,72,218,12,7,0,},},{{4,250,109,216,48,8,0,},{34,61,129,38,126,120,13,},{220,132,64,220,4,6,0,},{210,32,108,213,92,6,0,},},{{12,30,108,207,164,3,0,},
{216,204,109,216,200,4,0,},{213,32,68,218,100,5,0,},},{{211,176,112,206,216,7,0,},{209,48,120,21,214,80,13,},},{{212,176,120,21,238,229,12,},{206,188,108,206,200,4,0,},},
{{4,222,109,216,48,8,0,},{3,58,129,38,250,117,13,},{208,40,124,13,34,167,13,},},{{213,48,68,218,100,5,0,},{212,224,120,21,238,229,12,},},{{5,226,73,5,30,6,0,},},
{{206,172,108,206,200,4,0,},},{{34,69,121,21,114,120,13,},{238,152,69,226,148,8,0,},{207,24,128,38,186,82,13,},},{{220,124,108,214,172,5,0,},{208,56,72,218,12,7,0,},
{207,68,120,21,162,82,13,},},{{218,48,108,213,172,5,0,},{211,160,128,38,246,231,12,},},{{213,56,68,218,100,5,0,},{213,28,68,218,100,5,0,},},{{238,136,69,226,148,8,0,},
{226,144,109,224,172,5,0,},{216,248,113,216,16,5,0,},},{{14,70,108,213,164,3,0,},{220,100,68,220,16,6,0,},{216,212,69,5,102,5,0,},{212,244,64,212,4,6,0,},},
{{207,32,64,218,208,2,0,},},{{4,234,113,216,96,8,0,},{226,168,73,226,28,6,0,},{224,188,69,226,100,5,0,},},{{220,108,72,220,28,6,0,},{207,56,128,38,186,82,13,},},
{{52,34,117,48,166,3,0,},{216,228,69,5,102,5,0,},{208,204,108,20,70,6,0,},},{{16,194,109,55,174,3,0,},{209,88,112,213,180,0,0,},},{{16,134,109,224,164,3,0,},
{216,24,129,38,62,133,13,},{207,24,120,21,162,82,13,},},{{238,196,121,21,114,8,14,},{217,112,64,220,0,8,0,},{206,220,128,38,62,229,12,},},{{216,236,125,13,142,85,32,},
{207,48,108,213,48,2,0,},},{{217,132,64,220,0,8,0,},{212,176,128,38,250,229,12,},},{{17,238,109,216,164,3,0,},{221,36,72,218,24,8,0,},{209,24,128,38,242,80,13,},},
{{217,136,72,220,24,8,0,},{212,216,108,206,172,5,0,},{206,212,120,21,42,229,12,},},{{238,168,65,226,136,8,0,},{214,136,64,220,80,5,0,},{209,56,120,21,214,80,13,},},
{{5,206,69,5,18,6,0,},{217,104,128,38,246,103,13,},},{{5,214,73,5,30,6,0,},{3,70,65,3,6,6,0,},{211,232,124,13,38,72,13,},{211,188,120,21,234,231,12,},},
{{224,156,121,21,42,5,14,},{214,100,88,220,160,5,0,},{212,192,68,212,16,6,0,},},{{10,214,108,206,164,3,0,},{3,62,129,38,250,117,13,},},{{226,152,65,226,4,6,0,},
{213,36,124,13,142,165,13,},{211,232,120,21,234,231,12,},},{{5,222,113,216,220,5,0,},{4,26,129,38,126,136,13,},{221,60,112,213,216,7,0,},{206,196,68,212,100,5,0,},},
{{5,206,109,216,172,5,0,},{3,122,113,215,220,5,0,},{206,176,108,206,200,4,0,},},{{220,136,72,220,28,6,0,},{210,52,124,13,34,167,13,},{207,28,128,38,186,82,13,},},
{{4,238,129,38,126,136,13,},{210,52,128,38,210,86,13,},{207,28,124,13,26,163,13,},},{{5,230,121,21,238,133,13,},{3,54,113,215,220,5,0,},{213,52,72,218,120,5,0,},
{211,216,108,206,168,7,0,},},{{211,208,72,212,24,8,0,},{209,36,68,218,40,1,0,},},{{220,120,72,220,28,6,0,},{212,224,112,206,220,5,0,},{208,64,128,38,210,86,13,},},
{{207,8,105,207,136,3,0,},{207,88,120,21,162,82,13,},},{{215,80,69,3,102,5,0,},{211,200,108,206,168,7,0,},},{{224,168,109,224,200,4,0,},{210,52,108,213,92,6,0,},},
{{226,156,69,226,16,6,0,},{208,252,255,208,0,0,13,},},{{210,228,104,207,104,7,0,},},{{221,28,64,218,0,8,0,},{215,120,113,215,16,5,0,},{213,88,72,218,120,5,0,},},
{{34,65,65,3,138,8,0,},{221,88,120,21,234,87,13,},{209,88,68,218,40,1,0,},},{{210,0,104,207,104,7,0,},{208,88,120,21,190,86,13,},},{{3,82,129,38,250,117,13,},
{214,148,64,220,80,5,0,},{210,24,108,213,92,6,0,},},{{215,56,109,215,200,4,0,},{214,100,112,214,16,5,0,},},{{3,82,121,21,238,117,13,},{221,32,112,213,216,7,0,},
{217,156,108,214,168,7,0,},},{{214,112,88,220,160,5,0,},{206,216,112,206,16,5,0,},},{{4,2,130,38,126,136,13,},{220,148,120,21,238,101,13,},},{{20,254,4,211,0,0,0,},
{4,202,129,38,126,136,13,},{220,156,68,220,16,6,0,},},{{217,124,124,13,38,200,13,},},{{224,144,113,224,16,5,0,},{214,132,108,214,200,4,0,},{210,40,64,218,228,6,0,},},
{{215,44,109,215,200,4,0,},{208,32,124,13,34,167,13,},},{{20,214,4,211,0,0,0,},{34,69,69,3,150,8,0,},{213,32,124,13,142,165,13,},},{{211,176,120,21,234,231,12,},
{209,48,112,213,180,0,0,},},{{3,58,69,3,18,6,0,},{212,176,112,206,220,5,0,},{210,68,112,213,164,6,0,},},{{33,130,41,18,2,0,0,},{4,226,125,13,174,88,32,},
{34,77,121,21,114,120,13,},{210,56,124,13,34,167,13,},},{{220,116,108,214,172,5,0,},{210,48,112,213,164,6,0,},{208,88,128,38,210,86,13,},},{{18,62,109,215,164,3,0,},
{5,226,65,5,6,6,0,},{211,228,108,206,168,7,0,},{209,56,104,207,208,1,0,},},{{3,42,69,3,18,6,0,},{215,124,109,51,226,4,0,},},{{238,148,73,226,160,8,0,},
{212,252,64,212,4,6,0,},{208,48,108,213,92,6,0,},},{{215,128,113,215,16,5,0,},},{{8,10,97,209,0,0,0,},{211,212,108,206,168,7,0,},{209,32,128,38,242,80,13,},},
{{221,40,120,21,234,87,13,},{215,52,113,215,16,5,0,},{212,200,128,38,250,229,12,},},{{238,136,125,13,174,40,14,},{221,24,128,38,246,87,13,},{216,200,69,5,102,5,0,},},
{{207,40,108,213,48,2,0,},},{{4,214,129,38,126,136,13,},{207,32,72,218,0,3,0,},},{{226,168,65,226,4,6,0,},{206,224,88,212,160,5,0,},},{{4,222,65,5,138,8,0,},
{3,70,73,3,30,6,0,},{214,124,108,214,200,4,0,},},{{226,196,125,13,42,38,14,},{213,40,88,218,160,5,0,},{207,56,108,213,48,2,0,},},{{34,130,45,18,2,0,0,},
{215,44,69,3,102,5,0,},{213,88,112,213,16,5,0,},{209,88,120,21,214,80,13,},},{{34,61,113,215,96,8,0,},{238,188,69,226,148,8,0,},{213,64,68,218,100,5,0,},},
{{4,206,65,5,138,8,0,},{238,196,129,38,126,8,14,},{224,140,113,224,16,5,0,},{206,220,120,21,42,229,12,},},{{21,250,53,4,2,0,0,},{218,36,68,218,16,6,0,},
{210,64,124,13,34,167,13,},},{{218,60,112,213,220,5,0,},{216,0,66,5,82,5,0,},{215,60,69,3,102,5,0,},},{{217,120,124,13,38,200,13,},{216,224,73,5,122,5,0,},
{216,204,65,5,82,5,0,},},{{224,148,121,21,42,5,14,},{214,132,88,220,160,5,0,},},{{34,57,121,21,114,120,13,},{210,80,112,213,164,6,0,},{208,36,124,13,34,167,13,},},
{{215,52,125,13,142,53,32,},{213,28,124,13,142,165,13,},},{{5,214,65,5,6,6,0,},{221,52,64,218,0,8,0,},{211,188,112,206,216,7,0,},},{{212,192,124,13,42,70,13,},
{212,180,120,21,238,229,12,},},{{5,222,129,38,250,133,13,},{4,26,113,216,96,8,0,},{212,200,64,212,4,6,0,},{212,188,68,212,16,6,0,},},{{213,88,120,21,42,85,13,},},
{{3,130,109,215,172,5,0,},{221,60,120,21,234,87,13,},{213,24,128,38,62,85,13,},},{{206,252,72,212,120,5,0,},},{{4,238,69,5,150,8,0,},{220,136,112,214,220,5,0,},
{210,52,68,218,248,6,0,},},{{9,58,92,207,0,0,0,},{220,112,68,220,16,6,0,},{207,64,120,21,162,82,13,},},{{5,230,113,216,220,5,0,},{3,54,121,21,238,117,13,},
{214,120,64,220,80,5,0,},{213,52,64,218,80,5,0,},},{{28,30,44,14,2,0,0,},{224,160,109,224,200,4,0,},{206,244,112,206,16,5,0,},},{{238,140,125,13,174,40,14,},
{212,172,108,206,172,5,0,},{207,64,112,213,132,2,0,},},{{218,64,124,13,42,166,13,},{207,88,112,213,132,2,0,},},{{4,210,129,38,126,136,13,},{207,40,104,207,136,3,0,},},
{{226,148,113,224,220,5,0,},{215,52,89,3,162,5,0,},{211,220,108,206,168,7,0,},},{{34,81,113,215,96,8,0,},{216,208,89,5,162,5,0,},{207,80,68,218,232,2,0,},},
{{213,64,108,213,200,4,0,},{207,36,108,213,48,2,0,},},{{34,57,125,13,174,56,32,},{221,28,72,218,24,8,0,},{211,192,124,13,38,72,13,},},{{221,88,64,218,0,8,0,},
{217,148,108,214,168,7,0,},{211,192,128,38,246,231,12,},},{{39,138,45,16,2,0,0,},{220,104,128,38,250,101,13,},{214,156,108,214,200,4,0,},},{{212,212,64,212,4,6,0,},
{212,200,120,21,238,229,12,},{210,68,104,207,104,7,0,},},{{226,140,73,226,28,6,0,},},{{215,120,129,38,62,117,13,},{210,68,128,38,210,86,13,},},{{224,196,125,13,142,37,14,},
{224,136,65,226,80,5,0,},{206,216,72,212,120,5,0,},},{{34,45,125,13,174,56,32,},{220,148,112,214,220,5,0,},{207,52,124,13,26,163,13,},},{{34,121,129,38,126,120,13,},
{221,28,108,213,168,7,0,},},{{6,114,4,217,0,0,0,},{211,184,120,21,234,231,12,},{206,208,68,212,100,5,0,},},{{212,220,112,206,220,5,0,},{212,196,124,13,42,70,13,},},
{{4,250,125,13,174,88,32,},{217,124,68,220,12,8,0,},{210,32,124,13,34,167,13,},},{{224,144,121,21,42,5,14,},},{{221,56,112,213,216,7,0,},{213,40,64,218,80,5,0,},
{209,48,104,207,208,1,0,},},{{34,129,65,3,138,8,0,},{206,192,112,206,16,5,0,},},{{34,77,113,215,96,8,0,},{218,32,108,213,172,5,0,},},{{208,48,128,38,210,86,13,},},
{{18,42,109,215,164,3,0,},{5,226,121,21,238,133,13,},{213,68,64,218,80,5,0,},},{{7,54,104,207,0,0,0,},{34,53,121,21,114,120,13,},{211,228,128,38,246,231,12,},},
{{4,234,109,216,48,8,0,},{220,116,128,38,250,101,13,},{208,8,113,27,94,7,0,},},{{218,24,112,213,220,5,0,},{213,56,108,213,200,4,0,},{208,40,112,213,164,6,0,},},
{{209,40,112,213,180,0,0,},},{{226,152,121,21,238,5,14,},{212,228,108,206,172,5,0,},},{{0}},{{35,230,8,36,10,0,0,},{4,214,69,5,150,8,0,},{216,220,73,5,122,5,0,},},
{{7,2,113,7,166,3,0,},{4,250,129,38,126,136,13,},{209,80,120,21,214,80,13,},{207,40,128,38,186,82,13,},},{{211,196,128,38,246,231,12,},{206,224,64,212,80,5,0,},},
{{4,222,73,5,162,8,0,},{216,228,129,38,62,133,13,},{216,220,89,5,162,5,0,},},{{210,28,68,218,248,6,0,},},{{6,110,4,217,0,0,0,},{4,2,110,216,48,8,0,},},
{{9,18,92,207,0,0,0,},{238,196,69,226,148,8,0,},{217,112,124,13,38,200,13,},{210,64,128,38,210,86,13,},},{{4,206,73,5,162,8,0,},{214,116,88,220,160,5,0,},
{206,220,112,206,16,5,0,},},{{23,74,117,22,126,7,0,},{216,236,109,216,200,4,0,},{207,48,124,13,26,163,13,},},{{23,50,69,52,142,7,0,},{215,60,125,13,142,53,32,},
{210,36,72,218,12,7,0,},},{{11,70,100,207,0,0,0,},{10,226,108,206,164,3,0,},},{{224,148,113,224,16,5,0,},{217,156,112,214,216,7,0,},{212,216,124,13,42,70,13,},},
{{216,252,109,40,226,4,0,},{210,80,120,21,190,86,13,},{210,36,124,13,34,167,13,},},{{215,120,121,21,42,117,13,},{213,80,120,21,42,85,13,},},{{5,214,121,21,238,133,13,},
{221,52,120,21,234,87,13,},{214,136,120,21,42,101,13,},{211,188,72,212,24,8,0,},},{{238,160,125,13,174,40,14,},{218,88,112,213,220,5,0,},{212,180,112,206,220,5,0,},},
{{4,26,121,21,114,136,13,},{226,140,69,226,16,6,0,},{208,44,108,6,54,6,0,},},{{213,88,128,38,62,85,13,},{211,224,64,212,0,8,0,},},{{7,94,104,207,0,0,0,},
{3,62,121,21,238,117,13,},},{{6,42,4,221,0,0,0,},{211,216,128,38,246,231,12,},{206,252,64,212,80,5,0,},},{{220,112,128,38,250,101,13,},{208,52,68,218,248,6,0,},},
{{218,28,120,21,238,85,13,},{207,28,108,213,48,2,0,},},{{211,164,112,206,216,7,0,},{209,36,120,21,214,80,13,},{206,192,124,13,142,69,13,},},{{212,248,108,43,190,5,0,},
{206,244,120,21,42,229,12,},},{{29,66,40,14,2,0,0,},{238,196,109,224,48,8,0,},{216,200,89,5,162,5,0,},},{{218,64,68,218,16,6,0,},{207,88,72,218,0,3,0,},},
{{34,81,129,38,126,120,13,},{218,88,72,218,28,6,0,},{211,200,124,13,38,72,13,},},{{13,102,85,23,2,0,0,},{224,168,125,13,142,37,14,},{206,160,108,206,200,4,0,},},
{{34,81,121,21,114,120,13,},{34,65,69,3,150,8,0,},{208,80,112,213,164,6,0,},},{{218,80,68,218,16,6,0,},},{{44,74,4,29,2,0,0,},{221,80,108,213,168,7,0,},
{211,192,68,212,12,8,0,},},{{221,88,72,218,24,8,0,},{216,0,110,216,200,4,0,},},{{208,88,104,207,104,7,0,},},{{218,40,108,213,172,5,0,},{210,80,124,13,34,167,13,},},
{{224,196,109,224,200,4,0,},{215,56,125,13,142,53,32,},{209,68,72,218,68,1,0,},},{{34,45,129,38,126,120,13,},{217,156,124,13,38,200,13,},},{{25,254,40,10,2,0,0,},
{224,136,73,226,120,5,0,},{220,100,72,220,28,6,0,},{206,216,64,212,80,5,0,},},{{4,202,69,5,150,8,0,},{220,156,128,38,250,101,13,},{218,36,128,38,250,85,13,},},
{{217,124,64,220,0,8,0,},{214,112,128,38,62,101,13,},{211,244,68,212,12,8,0,},},{{34,69,65,3,138,8,0,},{211,184,112,206,216,7,0,},},{{214,132,124,13,142,197,13,},
{214,104,64,220,80,5,0,},},{{34,53,65,3,138,8,0,},{214,132,128,38,62,101,13,},{210,32,68,218,248,6,0,},},{{218,48,64,218,4,6,0,},{213,32,108,213,200,4,0,},
{211,244,112,206,216,7,0,},},{{16,154,109,224,164,3,0,},{34,77,129,38,126,120,13,},{221,56,120,21,234,87,13,},{213,40,72,218,120,5,0,},},{{34,129,73,3,162,8,0,},
{208,40,72,218,12,7,0,},{206,192,120,21,42,229,12,},},{{17,230,109,216,164,3,0,},{4,226,109,216,48,8,0,},{210,56,108,213,92,6,0,},{208,228,104,207,104,7,0,},},
{{7,50,104,207,0,0,0,},{3,78,109,215,172,5,0,},{213,48,108,213,200,4,0,},},{{18,130,109,215,164,3,0,},{5,226,113,216,220,5,0,},{3,42,129,38,250,117,13,},
{215,128,125,13,142,53,32,},},{{14,30,108,213,164,3,0,},},{{18,126,109,51,174,3,0,},{4,230,109,216,48,8,0,},{207,68,68,218,232,2,0,},},{{216,200,73,5,122,5,0,},
{215,68,113,215,16,5,0,},},{{211,212,124,13,38,72,13,},{209,40,120,21,214,80,13,},},{{13,98,85,23,2,0,0,},{11,42,100,207,0,0,0,},{226,152,113,224,220,5,0,},
{224,172,125,13,142,37,14,},},{{238,136,109,224,48,8,0,},{226,144,69,226,16,6,0,},},{{34,129,113,215,96,8,0,},{215,60,129,38,62,117,13,},},{{221,76,108,28,202,7,0,},
{209,80,112,213,180,0,0,},},{{9,42,92,207,0,0,0,},{206,224,72,212,120,5,0,},},{{4,222,113,216,96,8,0,},{4,214,109,216,48,8,0,},{210,4,112,9,54,7,0,},},
{{34,65,109,215,48,8,0,},{216,228,109,216,200,4,0,},{207,56,124,13,26,163,13,},},{{8,14,97,209,0,0,0,},{211,196,108,206,168,7,0,},{209,88,104,207,208,1,0,},},
{{34,41,129,38,126,120,13,},{212,188,72,212,28,6,0,},},{{226,184,109,39,206,5,0,},{214,116,64,220,80,5,0,},{212,208,124,13,42,70,13,},},{{12,6,109,207,164,3,0,},
{207,48,68,218,232,2,0,},},{{214,108,128,38,62,101,13,},{209,28,108,213,84,0,0,},},{{3,78,129,38,250,117,13,},{220,120,64,220,4,6,0,},{217,120,108,214,168,7,0,},},
{{238,168,125,13,174,40,14,},{214,136,124,13,142,197,13,},},{{214,128,128,38,62,101,13,},{208,36,108,213,92,6,0,},},{{213,80,112,213,16,5,0,},{213,28,108,213,200,4,0,},
{211,244,108,206,168,7,0,},},{{5,214,113,216,220,5,0,},{217,104,108,214,168,7,0,},{211,232,68,212,12,8,0,},{211,188,64,212,0,8,0,},},{{221,64,68,218,12,8,0,},
{210,36,128,38,210,86,13,},},{{220,128,120,21,238,101,13,},{211,180,128,38,246,231,12,},{209,36,112,213,180,0,0,},},{{10,194,108,206,164,3,0,},{211,224,72,212,24,8,0,},
{209,52,68,218,40,1,0,},},{{3,130,125,13,42,54,32,},{3,62,113,215,220,5,0,},{216,228,73,5,122,5,0,},},{{226,132,113,224,220,5,0,},{212,240,108,24,206,5,0,},
{206,252,120,21,42,229,12,},},{{10,198,108,206,164,3,0,},{207,4,112,9,50,3,0,},},{{4,210,65,5,138,8,0,},{218,28,112,213,220,5,0,},{207,64,104,207,136,3,0,},},
{{211,164,120,21,234,231,12,},{208,56,112,213,164,6,0,},},{{238,148,65,226,136,8,0,},{224,160,125,13,142,37,14,},{212,172,112,206,220,5,0,},},{{0}},{{207,88,64,218,208,2,0,},},
{{218,88,64,218,4,6,0,},{208,80,128,38,210,86,13,},},{{4,2,74,5,162,8,0,},{34,57,113,215,96,8,0,},{226,148,129,38,250,5,14,},},{{10,222,108,206,164,3,0,},
{4,210,121,21,114,136,13,},{208,80,104,207,104,7,0,},},{{214,156,128,38,62,101,13,},{207,36,124,13,26,163,13,},},{{226,196,129,38,250,5,14,},{221,28,120,21,234,87,13,},
{212,200,124,13,42,70,13,},},{{220,156,64,220,4,6,0,},{217,148,124,13,38,200,13,},{208,68,112,213,164,6,0,},},{{15,158,108,214,164,3,0,},{214,44,108,6,170,4,0,},
{212,212,124,13,42,70,13,},},{{0}},{{213,68,112,213,16,5,0,},{209,40,68,218,40,1,0,},},{{221,36,128,38,246,87,13,},{217,156,68,220,12,8,0,},{208,28,128,38,210,86,13,},},
{{11,18,100,207,0,0,0,},{217,132,72,220,24,8,0,},{214,112,112,214,16,5,0,},{206,216,88,212,160,5,0,},},{{34,121,69,3,150,8,0,},{218,32,124,13,42,166,13,},
{207,52,108,213,48,2,0,},},{{217,124,72,220,24,8,0,},{209,88,128,38,242,80,13,},},{{3,66,113,215,220,5,0,},{221,48,120,21,234,87,13,},{210,60,108,213,92,6,0,},},
{{47,22,81,45,2,0,0,},{34,61,109,215,48,8,0,},{214,104,120,21,42,101,13,},{210,32,128,38,210,86,13,},},{{46,22,57,45,2,0,0,},{212,196,128,38,250,229,12,},
{208,4,113,27,94,7,0,},{208,32,68,218,248,6,0,},},{{218,48,72,218,28,6,0,},{217,112,108,214,168,7,0,},{211,244,120,21,234,231,12,},},{{3,58,121,21,238,117,13,},
{220,104,108,214,172,5,0,},{206,188,88,212,160,5,0,},},{{226,136,121,21,238,5,14,},{224,152,129,38,62,5,14,},{212,184,112,206,220,5,0,},},{{6,106,4,217,0,0,0,},
{209,48,128,38,242,80,13,},{208,12,105,207,104,7,0,},},{{34,53,69,3,150,8,0,},{238,152,129,38,126,8,14,},},{{5,234,129,38,250,133,13,},{3,70,129,38,250,117,13,},
{209,56,64,218,12,1,0,},},{{17,2,110,216,164,3,0,},{212,160,120,21,238,229,12,},{206,96,16,35,250,3,0,},},{{5,202,73,5,30,6,0,},{216,204,89,5,162,5,0,},
{208,56,124,13,34,167,13,},},{{216,0,114,216,16,5,0,},{215,68,121,21,42,117,13,},{213,56,124,13,142,165,13,},},{{213,56,128,38,62,85,13,},{211,212,68,212,12,8,0,},
{209,40,64,218,12,1,0,},},{{238,144,113,224,96,8,0,},{208,56,128,38,210,86,13,},},{{238,172,73,226,160,8,0,},{206,232,68,212,100,5,0,},},{{218,84,108,44,190,5,0,},
{207,32,124,13,26,163,13,},},{{31,138,41,16,2,0,0,},{221,24,112,213,216,7,0,},{209,80,104,207,208,1,0,},},{{221,52,112,213,216,7,0,},{206,224,112,206,16,5,0,},},
{{4,222,121,21,114,136,13,},{221,64,128,38,246,87,13,},{210,28,128,38,210,86,13,},},{{220,100,108,214,172,5,0,},{214,124,68,220,100,5,0,},},{{5,2,122,21,238,133,13,},
{212,200,68,212,16,6,0,},{209,64,104,207,208,1,0,},},{{226,160,113,224,220,5,0,},{208,24,128,38,210,86,13,},{206,200,128,38,62,229,12,},},{{224,132,129,38,62,5,14,},
{214,116,72,220,120,5,0,},{214,92,128,38,62,101,13,},},{{220,124,128,38,250,101,13,},{218,36,124,13,42,166,13,},},{{21,226,53,4,2,0,0,},{10,250,108,43,174,3,0,},
{221,32,120,21,234,87,13,},{215,60,109,215,200,4,0,},},{{3,78,121,21,238,117,13,},{214,104,124,13,142,197,13,},{212,216,64,212,4,6,0,},},{{34,33,109,215,48,8,0,},
{208,40,128,38,210,86,13,},},{{4,254,109,40,66,8,0,},{226,188,65,226,4,6,0,},{210,36,108,213,92,6,0,},},{{238,188,129,38,126,8,14,},{213,80,72,218,120,5,0,},},
{{215,52,129,38,62,117,13,},{213,28,128,38,62,85,13,},},{{20,226,4,211,0,0,0,},{238,160,109,224,48,8,0,},{214,100,120,21,42,101,13,},{208,36,128,38,210,86,13,},},
{{220,128,112,214,220,5,0,},{213,36,64,218,80,5,0,},{209,52,128,38,242,80,13,},},{{12,2,108,207,164,3,0,},{5,250,113,216,220,5,0,},},{{3,130,69,3,18,6,0,},
{3,62,73,3,30,6,0,},},{{226,132,121,21,238,5,14,},{214,156,124,13,142,197,13,},{206,252,112,206,16,5,0,},},{{238,156,69,226,148,8,0,},{218,52,68,218,16,6,0,},
{215,56,69,3,102,5,0,},},{{215,64,113,215,16,5,0,},{214,108,88,220,160,5,0,},{209,0,105,207,208,1,0,},},{{5,238,113,216,220,5,0,},{213,60,128,38,62,85,13,},
{209,36,104,207,208,1,0,},},{{4,2,70,5,150,8,0,},{226,156,113,224,220,5,0,},{212,172,120,21,238,229,12,},{207,92,104,207,136,3,0,},},{{238,140,69,226,148,8,0,},
{224,160,129,38,62,5,14,},{215,120,73,3,122,5,0,},},{{9,38,92,207,0,0,0,},{211,208,128,38,246,231,12,},{209,8,113,27,190,1,0,},},{{226,148,69,226,16,6,0,},
{224,168,65,226,80,5,0,},},{{5,2,70,5,18,6,0,},},{{216,208,65,5,82,5,0,},{210,8,112,8,66,7,0,},{208,12,108,11,82,7,0,},},{{12,18,109,207,164,3,0,},
{8,94,96,209,0,0,0,},{207,36,68,218,232,2,0,},},{{221,80,124,13,38,168,13,},{216,236,89,5,162,5,0,},{214,132,120,21,42,101,13,},},{{215,40,129,38,62,117,13,},
{213,48,88,218,160,5,0,},},{{32,2,46,17,2,0,0,},{216,224,65,5,82,5,0,},{208,28,108,213,92,6,0,},},{{218,40,124,13,42,166,13,},{207,60,108,213,48,2,0,},},
{{54,30,113,46,182,3,0,},{6,50,4,221,0,0,0,},{213,68,72,218,120,5,0,},{209,68,120,21,214,80,13,},},{{212,164,108,206,172,5,0,},},{{214,112,120,21,42,101,13,},
{212,220,108,206,172,5,0,},},{{220,156,112,214,220,5,0,},{207,204,108,20,22,2,0,},},{{5,202,69,5,18,6,0,},{221,40,68,218,12,8,0,},{209,228,104,207,208,1,0,},},
{{5,210,113,216,220,5,0,},{221,48,112,213,216,7,0,},{217,100,68,220,12,8,0,},{213,32,128,38,62,85,13,},},{{9,90,92,207,0,0,0,},{214,104,112,214,16,5,0,},
{212,196,68,212,16,6,0,},{208,32,128,38,210,86,13,},},{{220,132,120,21,238,101,13,},{208,4,105,207,104,7,0,},},{{16,198,109,224,164,3,0,},{224,148,69,226,100,5,0,},
{221,56,68,218,12,8,0,},},{{25,234,40,10,2,0,0,},{3,58,113,215,220,5,0,},{217,108,124,13,38,200,13,},},{{226,136,113,224,220,5,0,},{212,184,120,21,238,229,12,},
{206,180,108,206,200,4,0,},},{{215,128,121,21,42,117,13,},},{{8,58,96,209,0,0,0,},{218,76,108,28,206,5,0,},{213,48,124,13,142,165,13,},},{{215,52,121,21,42,117,13,},
{209,56,72,218,68,1,0,},},{{212,252,124,13,42,70,13,},{212,160,112,206,220,5,0,},},{{220,124,64,220,4,6,0,},{208,60,120,21,190,86,13,},},{{6,134,4,217,0,0,0,},
{215,68,65,3,82,5,0,},{211,212,128,38,246,231,12,},{209,32,108,213,84,0,0,},},{{3,70,113,215,220,5,0,},{215,128,89,3,162,5,0,},{209,40,72,218,68,1,0,},},
{{9,10,93,207,0,0,0,},{238,144,121,21,114,8,14,},{224,172,109,224,200,4,0,},},{{224,136,121,21,42,5,14,},{209,8,105,207,208,1,0,},},{{4,202,113,216,96,8,0,},
{226,144,113,224,220,5,0,},{215,68,89,3,162,5,0,},},{{7,2,105,207,0,0,0,},{5,250,121,21,238,133,13,},{221,68,68,218,12,8,0,},{221,24,120,21,234,87,13,},},
{{31,198,41,16,2,0,0,},{224,188,109,224,200,4,0,},{215,44,129,38,62,117,13,},{206,224,120,21,42,229,12,},},{{218,68,108,213,172,5,0,},{216,220,113,216,16,5,0,},
{211,252,64,212,0,8,0,},},{{216,0,90,5,162,5,0,},{216,204,73,5,122,5,0,},},{{7,18,105,207,0,0,0,},{5,2,114,216,220,5,0,},{213,64,112,213,16,5,0,},},
{{226,160,121,21,238,5,14,},{217,152,108,41,186,7,0,},{210,80,72,218,12,7,0,},},{{34,41,109,215,48,8,0,},{214,116,112,214,16,5,0,},{212,252,72,212,28,6,0,},},
{{17,206,109,216,164,3,0,},{218,52,128,38,250,85,13,},{216,236,69,5,102,5,0,},},{{37,202,41,17,2,0,0,},{8,38,96,209,0,0,0,},{209,28,124,13,98,161,13,},},
{{3,78,113,215,220,5,0,},{217,136,108,214,168,7,0,},{212,216,72,212,28,6,0,},},{{238,168,109,224,48,8,0,},{214,136,108,214,200,4,0,},{214,108,120,21,42,101,13,},},
{{12,70,108,207,164,3,0,},{3,130,73,3,30,6,0,},{221,64,64,218,0,8,0,},{211,188,124,13,38,72,13,},},{{6,58,4,221,0,0,0,},{215,120,65,3,82,5,0,},
{213,80,64,218,80,5,0,},{211,232,128,38,246,231,12,},},{{10,246,108,206,164,3,0,},{218,48,112,213,220,5,0,},{217,104,124,13,38,200,13,},},{{4,230,73,5,162,8,0,},
{212,188,112,206,220,5,0,},{206,196,128,38,62,229,12,},},{{217,116,128,38,246,103,13,},{213,36,88,218,160,5,0,},},{{0}},{{3,62,65,3,6,6,0,},{226,136,69,226,16,6,0,},
{206,196,108,206,200,4,0,},},{{3,42,65,3,6,6,0,},{215,64,129,38,62,117,13,},{212,164,120,21,238,229,12,},},{{0}},{{29,90,40,14,2,0,0,},{5,230,69,5,18,6,0,},
{212,164,128,38,250,229,12,},{209,60,108,213,84,0,0,},},{{5,238,121,21,238,133,13,},{3,46,65,3,6,6,0,},{211,208,108,206,168,7,0,},{206,168,32,42,82,4,0,},},
{{9,6,93,207,0,0,0,},{238,148,113,224,96,8,0,},{226,156,73,226,28,6,0,},{208,64,108,213,92,6,0,},},{{49,74,117,22,166,3,0,},{220,120,112,214,220,5,0,},
{216,200,113,216,16,5,0,},{212,224,72,212,28,6,0,},},{{8,230,96,209,0,0,0,},{213,60,108,213,200,4,0,},{213,52,108,213,200,4,0,},},{{18,54,109,215,164,3,0,},
{224,168,73,226,120,5,0,},},{{226,172,73,226,28,6,0,},{212,232,68,212,16,6,0,},{206,228,112,206,16,5,0,},},{{4,210,73,5,162,8,0,},{216,208,121,21,42,133,13,},
{206,200,108,206,200,4,0,},},{{10,186,108,206,164,3,0,},{215,68,129,38,62,117,13,},{208,68,108,213,92,6,0,},},{{4,238,113,216,96,8,0,},{215,40,69,3,102,5,0,},
{207,0,113,7,150,3,0,},},{{215,80,109,215,200,4,0,},{214,156,88,220,160,5,0,},},{{216,224,89,5,162,5,0,},{214,104,88,220,160,5,0,},{210,68,68,218,248,6,0,},},
{{211,196,120,21,234,231,12,},},{{7,38,104,207,0,0,0,},{218,40,128,38,250,85,13,},{209,68,112,213,180,0,0,},},{{226,188,121,21,238,5,14,},{214,148,128,38,62,101,13,},
{212,220,120,21,238,229,12,},},{{34,121,121,21,114,120,13,},{218,32,64,218,4,6,0,},{210,16,112,7,114,7,0,},},{{12,90,108,207,164,3,0,},{220,156,120,21,238,101,13,},
{220,120,108,214,172,5,0,},},{{22,54,77,34,9,0,0,},{211,252,112,206,216,7,0,},},{{5,210,73,5,30,6,0,},{3,66,65,3,6,6,0,},{221,48,72,218,24,8,0,},
{217,100,124,13,38,200,13,},},{{34,61,125,13,174,56,32,},{220,116,72,220,28,6,0,},{210,40,120,21,190,86,13,},},{{220,132,112,214,220,5,0,},{216,248,109,216,200,4,0,},},
{{24,190,44,10,2,0,0,},{213,40,124,13,142,165,13,},{211,224,68,212,12,8,0,},},{{7,18,104,207,0,0,0,},{224,152,69,226,100,5,0,},{206,188,72,212,120,5,0,},},
{{226,136,73,226,28,6,0,},{212,244,124,13,42,70,13,},},{{18,122,109,215,164,3,0,},{216,248,125,13,142,85,32,},{208,40,120,21,190,86,13,},},{{14,86,108,44,174,3,0,},
{215,76,113,215,16,5,0,},{212,160,128,38,250,229,12,},},{{5,234,113,216,220,5,0,},{3,126,109,51,190,5,0,},},{{238,152,121,21,114,8,14,},{210,48,64,218,228,6,0,},
{208,48,72,218,12,7,0,},},{{220,124,72,220,28,6,0,},{208,56,108,213,92,6,0,},},{{7,34,104,207,0,0,0,},{209,4,113,27,190,1,0,},{208,80,68,218,248,6,0,},},
{{7,10,105,207,0,0,0,},{3,34,113,215,220,5,0,},{221,68,124,13,38,168,13,},{215,128,65,3,82,5,0,},},{{11,34,100,207,0,0,0,},{213,36,128,38,62,85,13,},
{206,232,120,21,42,229,12,},},{{4,214,113,216,96,8,0,},},{{207,32,108,213,48,2,0,},},{{5,250,65,5,6,6,0,},{224,156,69,226,100,5,0,},},{{11,30,100,207,0,0,0,},
{226,168,121,21,238,5,14,},{217,144,108,26,202,7,0,},},{{216,220,121,21,42,133,13,},{214,124,128,38,62,101,13,},{212,200,72,212,28,6,0,},},{{226,168,129,38,250,5,14,},
{217,116,68,220,12,8,0,},},{{13,46,85,34,1,0,0,},{209,64,120,21,214,80,13,},},{{11,2,101,207,0,0,0,},{226,160,65,226,4,6,0,},{216,208,125,13,142,85,32,},},
{{238,140,65,226,136,8,0,},{212,208,68,212,16,6,0,},{210,64,108,213,92,6,0,},},{{11,10,101,207,0,0,0,},{218,36,108,213,172,5,0,},},{{7,58,104,207,0,0,0,},
{221,36,108,213,168,7,0,},{214,136,112,214,16,5,0,},},{{9,2,92,207,0,0,0,},{6,118,4,217,0,0,0,},{206,212,68,212,100,5,0,},},{{5,206,121,21,238,133,13,},
{214,108,112,214,16,5,0,},{210,88,68,218,248,6,0,},},{{224,144,73,226,120,5,0,},{218,52,108,213,172,5,0,},},{{215,52,69,3,102,5,0,},{213,80,88,218,160,5,0,},
{211,252,128,38,246,231,12,},},{{214,100,68,220,100,5,0,},{206,204,108,20,146,4,0,},},{{4,230,65,5,138,8,0,},{226,140,113,224,220,5,0,},{212,188,120,21,238,229,12,},},
{{12,82,108,207,164,3,0,},},{{216,212,89,5,162,5,0,},{209,52,108,213,84,0,0,},},{{13,90,85,23,2,0,0,},{5,222,65,5,6,6,0,},{215,56,65,3,82,5,0,},
{206,184,120,21,42,229,12,},},{{3,122,65,3,6,6,0,},{212,164,112,206,220,5,0,},{210,52,112,213,164,6,0,},},{{218,28,68,218,16,6,0,},},{{226,132,129,38,250,5,14,},
{211,216,72,212,24,8,0,},},{{5,238,65,5,6,6,0,},{3,46,121,21,238,117,13,},{215,120,69,3,102,5,0,},{206,168,24,42,18,4,0,},},{{226,156,65,226,4,6,0,},
{224,160,69,226,100,5,0,},{206,244,88,212,160,5,0,},},{{220,120,120,21,238,101,13,},{216,200,121,21,42,133,13,},{212,224,64,212,4,6,0,},},{{218,88,124,13,42,166,13,},
{211,200,72,212,24,8,0,},{207,80,128,38,186,82,13,},},{{238,172,125,13,174,40,14,},{212,232,128,38,250,229,12,},},{{3,118,109,34,206,5,0,},{226,148,121,21,238,5,14,},
{206,228,120,21,42,229,12,},},{{216,208,113,216,16,5,0,},{214,132,68,220,100,5,0,},{207,80,108,213,48,2,0,},},{{220,104,68,220,16,6,0,},{213,232,0,12,210,3,0,},
{212,252,108,206,172,5,0,},},{{13,42,85,34,1,0,0,},{3,122,73,3,30,6,0,},{217,148,72,220,24,8,0,},},{{39,198,45,16,2,0,0,},{11,94,100,207,0,0,0,},
{220,100,64,220,4,6,0,},},{{34,45,69,3,150,8,0,},{214,148,108,214,200,4,0,},{208,28,124,13,34,167,13,},},{{215,44,121,21,42,117,13,},{215,32,113,215,16,5,0,},},
{{213,68,88,218,160,5,0,},{209,68,104,207,208,1,0,},},{{226,188,113,224,220,5,0,},{221,32,64,218,0,8,0,},{212,212,128,38,250,229,12,},},{{4,202,121,21,114,136,13,},
{34,121,113,215,96,8,0,},{218,32,72,218,28,6,0,},},{{212,192,108,206,172,5,0,},},{{220,108,112,214,220,5,0,},{211,252,72,212,24,8,0,},{210,48,124,13,34,167,13,},},
{{3,66,73,3,30,6,0,},{214,136,72,220,120,5,0,},{206,208,108,206,200,4,0,},},{{224,144,65,226,80,5,0,},{210,40,112,213,164,6,0,},},{{14,26,108,213,164,3,0,},
{213,32,88,218,160,5,0,},{210,204,108,20,70,6,0,},},{{0}},{{217,108,108,214,168,7,0,},{212,244,128,38,250,229,12,},{206,188,64,212,80,5,0,},},{{226,136,65,226,4,6,0,},
{221,40,108,213,168,7,0,},{206,192,88,212,160,5,0,},},{{213,40,128,38,62,85,13,},},{{211,228,112,206,216,7,0,},},{{18,34,109,215,164,3,0,},{6,90,4,221,0,0,0,},
{5,234,121,21,238,133,13,},{217,92,108,214,168,7,0,},},{{208,68,68,218,248,6,0,},{208,48,64,218,228,6,0,},},{{216,204,113,216,16,5,0,},{206,164,128,38,62,229,12,},},
{{209,4,105,207,208,1,0,},{209,32,124,13,98,161,13,},},{{224,136,125,13,142,37,14,},{215,128,73,3,122,5,0,},},{{21,2,54,4,2,0,0,},{8,66,96,209,0,0,0,},
{226,144,121,21,238,5,14,},{206,232,112,206,16,5,0,},},{{216,212,121,21,42,133,13,},{207,40,72,218,0,3,0,},},{{19,174,113,238,188,3,0,},{211,216,68,212,12,8,0,},},
{{22,82,77,34,9,0,0,},{15,134,108,214,164,3,0,},{5,250,73,5,30,6,0,},{221,28,112,213,216,7,0,},},{{226,168,113,224,220,5,0,},{224,188,125,13,142,37,14,},
{216,224,69,5,102,5,0,},},{{216,228,89,5,162,5,0,},{214,124,120,21,42,101,13,},{207,56,72,218,0,3,0,},},{{211,196,64,212,0,8,0,},{206,224,128,38,62,229,12,},},
{{22,66,77,34,9,0,0,},{214,148,112,214,16,5,0,},{209,64,112,213,180,0,0,},},{{226,160,73,226,28,6,0,},{212,208,128,38,250,229,12,},},{{4,206,113,216,96,8,0,},
{34,41,125,13,174,56,32,},{224,140,65,226,80,5,0,},},{{218,60,108,213,172,5,0,},{215,60,89,3,162,5,0,},{209,28,64,218,12,1,0,},},{{13,54,85,34,1,0,0,},
{224,148,129,38,62,5,14,},},{{221,64,124,13,38,168,13,},{217,136,124,13,38,200,13,},},{{220,144,108,26,206,5,0,},{210,88,124,13,34,167,13,},},{{34,57,73,3,162,8,0,},
{210,80,64,218,228,6,0,},{210,36,68,218,248,6,0,},},{{5,26,121,21,238,133,13,},{216,248,89,5,162,5,0,},{216,228,65,5,82,5,0,},},{{224,156,109,224,200,4,0,},
{212,208,112,206,220,5,0,},},{{11,50,100,207,0,0,0,},{210,28,72,218,12,7,0,},},{{13,122,85,34,1,0,0,},{226,172,65,226,4,6,0,},{208,56,120,21,190,86,13,},},
{{12,230,108,207,164,3,0,},{211,180,108,206,168,7,0,},},{{5,222,73,5,30,6,0,},{206,184,112,206,16,5,0,},},{{238,156,121,21,114,8,14,},{211,220,120,21,234,231,12,},
{208,52,104,207,104,7,0,},},{{220,136,128,38,250,101,13,},{220,112,120,21,238,101,13,},{207,28,72,218,0,3,0,},},{{22,130,77,34,9,0,0,},{8,70,96,209,0,0,0,},
{209,0,113,7,226,1,0,},{206,252,128,38,62,229,12,},},{{5,238,73,5,30,6,0,},{3,46,113,215,220,5,0,},{218,24,120,21,238,85,13,},},{{19,162,113,238,188,3,0,},
{9,54,92,207,0,0,0,},{208,60,112,213,164,6,0,},{206,244,64,212,80,5,0,},},{{215,20,81,45,198,3,0,},{207,88,108,213,48,2,0,},},{{28,90,44,14,2,0,0,},
{211,200,64,212,0,8,0,},},{{220,112,64,220,4,6,0,},{208,68,104,207,104,7,0,},},{{4,238,125,13,174,88,32,},{226,172,121,21,238,5,14,},{210,84,108,44,118,6,0,},},
{{221,68,112,213,216,7,0,},{208,80,72,218,12,7,0,},},{{34,45,113,215,96,8,0,},{218,80,108,213,172,5,0,},},{{13,130,85,34,1,0,0,},{221,88,108,213,168,7,0,},
{217,148,64,220,0,8,0,},{211,196,124,13,38,72,13,},},{{18,82,109,215,164,3,0,},{216,224,125,13,142,85,32,},{208,88,68,218,248,6,0,},},{{217,156,128,38,246,103,13,},
{210,24,120,21,190,86,13,},{208,28,68,218,248,6,0,},},{{218,40,68,218,16,6,0,},{215,56,129,38,62,117,13,},{215,32,121,21,42,117,13,},},{{214,148,88,220,160,5,0,},
{207,60,128,38,186,82,13,},},{{217,132,124,13,38,200,13,},{206,216,108,206,200,4,0,},},{{5,222,121,21,238,133,13,},{216,232,113,216,16,5,0,},{207,52,64,218,208,2,0,},},
{{220,148,128,38,250,101,13,},{220,116,68,220,16,6,0,},{218,56,68,218,16,6,0,},},{{224,136,129,38,62,5,14,},{221,40,124,13,38,168,13,},{206,192,128,38,62,229,12,},},
{{217,100,108,214,168,7,0,},{216,212,125,13,142,85,32,},},{{25,190,40,10,2,0,0,},{208,32,104,207,104,7,0,},},{{238,196,73,226,160,8,0,},{217,100,128,38,246,103,13,},
{207,8,112,8,66,3,0,},},{{8,50,96,209,0,0,0,},{213,40,108,213,200,4,0,},{209,48,68,218,40,1,0,},},{{5,202,113,216,220,5,0,},{212,176,108,206,172,5,0,},
{206,188,120,21,42,229,12,},},{{6,150,4,217,0,0,0,},{217,108,128,38,246,103,13,},{206,192,64,212,80,5,0,},},{{210,56,68,218,248,6,0,},{207,0,104,207,136,3,0,},},
{{213,100,0,12,210,3,0,},{208,56,64,218,228,6,0,},},{{3,42,121,21,238,117,13,},},{{9,50,92,207,0,0,0,},{238,152,73,226,160,8,0,},{208,68,124,13,34,167,13,},
{208,48,120,21,190,86,13,},},{{216,204,121,21,42,133,13,},{207,16,104,207,136,3,0,},},{{224,196,73,226,120,5,0,},{211,220,112,206,216,7,0,},},{{5,210,129,38,250,133,13,},
{34,57,65,3,138,8,0,},{238,144,69,226,148,8,0,},},{{19,198,113,238,188,3,0,},{238,136,73,226,160,8,0,},{224,156,65,226,80,5,0,},},{{216,212,113,216,16,5,0,},
{207,40,64,218,208,2,0,},},{{209,80,128,38,242,80,13,},},{{209,80,72,218,68,1,0,},},{{220,108,68,220,16,6,0,},{216,220,69,5,102,5,0,},},{{214,124,112,214,16,5,0,},
{207,56,64,218,208,2,0,},},{{215,44,113,215,16,5,0,},{211,196,72,212,24,8,0,},},{{213,64,88,218,160,5,0,},{209,64,72,218,68,1,0,},{207,48,128,38,186,82,13,},},
{{20,190,4,211,0,0,0,},{11,82,100,207,0,0,0,},{224,132,109,224,200,4,0,},},{{4,206,121,21,114,136,13,},{224,140,73,226,120,5,0,},{217,112,128,38,246,103,13,},
{208,24,108,213,92,6,0,},},{{12,14,109,207,164,3,0,},{5,206,125,13,42,86,32,},{238,160,129,38,126,8,14,},{209,28,72,218,68,1,0,},},{{221,36,124,13,38,168,13,},
{217,120,64,220,0,8,0,},{206,212,128,38,62,229,12,},},{{11,66,100,207,0,0,0,},{224,148,109,224,200,4,0,},{220,92,112,214,220,5,0,},{217,136,68,220,12,8,0,},},
{{218,60,128,38,250,85,13,},{214,108,64,220,80,5,0,},},{{17,250,109,216,164,3,0,},{218,52,124,13,42,166,13,},{208,36,68,218,248,6,0,},},{{5,26,129,38,250,133,13,},
{217,104,64,220,0,8,0,},{211,188,108,206,168,7,0,},},{{238,160,65,226,136,8,0,},{226,144,129,38,250,5,14,},{212,192,72,212,28,6,0,},},{{212,200,108,206,172,5,0,},},
{{10,182,108,206,164,3,0,},{238,196,113,224,96,8,0,},{213,88,108,213,200,4,0,},},{{226,160,69,226,16,6,0,},{209,52,124,13,98,161,13,},},{{3,122,125,13,42,54,32,},
{3,54,129,38,250,117,13,},{226,196,69,226,16,6,0,},},{{218,28,128,38,250,85,13,},{211,160,108,206,168,7,0,},{210,52,104,207,104,7,0,},},{{220,112,112,214,220,5,0,},
{207,28,64,218,208,2,0,},},{{34,42,45,18,2,0,0,},{5,230,109,216,172,5,0,},{211,216,120,21,234,231,12,},},{{209,36,72,218,68,1,0,},},{{34,65,125,13,174,56,32,},
{216,0,122,21,42,133,13,},{206,244,72,212,120,5,0,},},{{0}},{{218,88,108,213,172,5,0,},{214,132,64,220,80,5,0,},{210,80,104,207,104,7,0,},},{{15,122,108,214,164,3,0,},
{10,254,108,206,164,3,0,},{206,160,112,206,16,5,0,},},{{226,172,113,224,220,5,0,},{212,232,124,13,42,70,13,},},{{218,88,128,38,250,85,13,},{208,80,64,218,228,6,0,},
{207,80,124,13,26,163,13,},},{{221,80,72,218,24,8,0,},{215,40,121,21,42,117,13,},{209,84,108,44,118,0,0,},},{{221,28,128,38,246,87,13,},{215,44,125,13,142,53,32,},},
{{238,188,65,226,136,8,0,},{224,184,109,39,250,4,0,},{214,156,64,220,80,5,0,},},{{210,68,124,13,34,167,13,},{210,24,112,213,164,6,0,},},{{221,32,72,218,24,8,0,},},
{{221,32,124,13,38,168,13,},},{{238,172,65,226,136,8,0,},{224,136,109,224,200,4,0,},},{{216,232,121,21,42,133,13,},{214,120,120,21,42,101,13,},{207,52,72,218,0,3,0,},},
{{218,56,124,13,42,166,13,},},{{217,124,112,214,216,7,0,},},{{22,46,77,34,9,0,0,},{238,148,121,21,114,8,14,},{206,208,124,13,142,69,13,},},{{34,53,109,215,48,8,0,},
{210,40,128,38,210,86,13,},{210,32,104,207,104,7,0,},},{{12,66,108,207,164,3,0,},{213,36,72,218,120,5,0,},{213,32,72,218,120,5,0,},},{{209,48,124,13,98,161,13,},},
{{13,86,85,23,2,0,0,},{226,196,121,21,238,5,14,},{224,152,125,13,142,37,14,},{206,188,112,206,16,5,0,},},{{11,58,100,207,0,0,0,},{34,129,121,21,114,120,13,},
{214,128,108,214,200,4,0,},{206,192,72,212,120,5,0,},},{{220,116,120,21,238,101,13,},{213,48,72,218,120,5,0,},{207,76,108,28,106,2,0,},},{{3,70,121,21,238,117,13,},
{34,129,125,13,174,56,32,},},{{5,226,129,38,250,133,13,},{3,42,113,215,220,5,0,},{226,196,109,224,172,5,0,},},{{4,234,121,21,114,136,13,},{210,48,120,21,190,86,13,},
{208,48,112,213,164,6,0,},},{{208,56,68,218,248,6,0,},{207,16,112,7,150,3,0,},},{{5,214,69,5,18,6,0,},{238,160,69,226,148,8,0,},{221,68,72,218,24,8,0,},},
{{15,102,108,214,164,3,0,},{6,30,4,221,0,0,0,},{206,240,108,24,250,4,0,},},{{238,136,65,226,136,8,0,},{211,216,64,212,0,8,0,},},{{14,58,108,213,164,3,0,},
{216,212,73,5,122,5,0,},{207,40,120,21,162,82,13,},},{{3,82,113,215,220,5,0,},{214,116,124,13,142,197,13,},{207,32,68,218,232,2,0,},},{{11,54,100,207,0,0,0,},
{209,80,64,218,12,1,0,},},{{24,254,44,10,2,0,0,},{220,132,108,214,172,5,0,},{214,148,124,13,142,197,13,},},{{42,98,20,35,10,0,0,},{3,46,125,13,42,54,32,},
{210,28,120,21,190,86,13,},},{{215,44,73,3,122,5,0,},{211,196,112,206,216,7,0,},},{{6,138,4,217,0,0,0,},{208,92,104,207,104,7,0,},},{{238,196,125,13,174,40,14,},
{217,112,68,220,12,8,0,},},{{7,42,104,207,0,0,0,},{5,210,65,5,6,6,0,},{216,236,113,216,16,5,0,},{213,68,120,21,42,85,13,},},{{215,60,73,3,122,5,0,},},
{{11,230,100,207,0,0,0,},{11,2,100,207,0,0,0,},{217,120,72,220,24,8,0,},},{{217,136,112,214,216,7,0,},{216,228,125,13,142,85,32,},{206,212,124,13,142,69,13,},},
{{3,58,125,13,42,54,32,},{210,88,108,213,92,6,0,},{207,252,255,208,8,0,13,},},{{10,190,108,206,164,3,0,},{215,120,109,215,200,4,0,},{213,80,108,213,200,4,0,},
{213,28,112,213,16,5,0,},},{{33,42,41,18,2,0,0,},{226,172,125,13,42,38,14,},{217,104,72,220,24,8,0,},},{{238,148,129,38,126,8,14,},{224,156,125,13,142,37,14,},
{212,192,64,212,4,6,0,},},{{9,70,92,207,0,0,0,},{3,130,129,38,250,117,13,},{3,122,129,38,250,117,13,},{214,92,120,21,42,101,13,},},{{213,36,120,21,42,85,13,},},
{{13,58,85,34,1,0,0,},{215,52,73,3,122,5,0,},{211,224,120,21,234,231,12,},},{{5,230,129,38,250,133,13,},{216,200,125,13,142,85,32,},},{{220,136,68,220,16,6,0,},
{208,52,120,21,190,86,13,},{207,64,128,38,186,82,13,},},{{220,112,72,220,28,6,0,},{218,28,108,213,172,5,0,},{207,28,120,21,162,82,13,},},{{3,54,109,215,172,5,0,},
{215,64,89,3,162,5,0,},{211,216,112,206,216,7,0,},},{{3,34,121,21,238,117,13,},{209,36,64,218,12,1,0,},},{{220,120,68,220,16,6,0,},{212,224,124,13,42,70,13,},
{208,60,128,38,210,86,13,},},{{4,202,65,5,138,8,0,},{218,64,112,213,220,5,0,},{207,88,124,13,26,163,13,},},{{14,66,108,213,164,3,0,},{215,80,121,21,42,117,13,},
{208,16,112,7,114,7,0,},},{{226,148,109,224,172,5,0,},{206,160,120,21,42,229,12,},},{{11,38,100,207,0,0,0,},{238,132,113,224,96,8,0,},{209,68,64,218,12,1,0,},},
{{220,148,72,220,28,6,0,},{220,104,112,214,220,5,0,},},{{221,80,64,218,0,8,0,},{216,224,113,216,16,5,0,},{211,232,108,206,168,7,0,},},{{9,82,92,207,0,0,0,},
{221,88,124,13,38,168,13,},},{{238,188,121,21,114,8,14,},{214,156,120,21,42,101,13,},{214,148,68,220,100,5,0,},},{{34,45,109,215,48,8,0,},{216,224,121,21,42,133,13,},
{214,120,88,220,160,5,0,},},{{5,222,125,13,42,86,32,},},{{50,86,77,49,2,0,0,},{3,82,125,13,42,54,32,},{226,188,69,226,16,6,0,},{216,224,129,38,62,133,13,},},
{{5,202,129,38,250,133,13,},{221,40,128,38,246,87,13,},{217,132,108,214,168,7,0,},{206,216,124,13,142,69,13,},},{{220,148,124,13,42,198,13,},{207,52,112,213,132,2,0,},},
{{10,162,108,206,164,3,0,},{7,18,112,7,166,3,0,},{213,76,108,28,250,4,0,},},{{34,53,73,3,162,8,0,},{217,132,128,38,246,103,13,},{217,124,120,21,234,103,13,},},
{{34,61,73,3,162,8,0,},{226,156,121,21,238,5,14,},{224,144,125,13,142,37,14,},},{{4,250,113,216,96,8,0,},{216,248,65,5,82,5,0,},{210,32,112,213,164,6,0,},
{208,32,120,21,190,86,13,},},{{5,202,125,13,42,86,32,},{213,32,64,218,80,5,0,},{212,244,108,206,172,5,0,},},{{221,56,108,213,168,7,0,},{217,120,112,214,216,7,0,},},
{{15,94,108,214,164,3,0,},{221,68,128,38,246,87,13,},{217,108,68,220,12,8,0,},{206,180,128,38,62,229,12,},},{{4,226,121,21,114,136,13,},{210,56,120,21,190,86,13,},},
{{220,116,112,214,220,5,0,},{213,48,64,218,80,5,0,},},{{5,226,69,5,18,6,0,},{215,76,129,38,62,117,13,},{209,56,108,213,84,0,0,},},{{15,110,108,214,164,3,0,},
{3,42,73,3,30,6,0,},{206,248,108,43,226,4,0,},},{{6,82,4,221,0,0,0,},{224,196,69,226,100,5,0,},{208,48,104,207,104,7,0,},},{{220,120,128,38,250,101,13,},
{207,68,124,13,26,163,13,},},{{221,68,64,218,0,8,0,},{211,220,128,38,246,231,12,},{209,40,108,213,84,0,0,},},{{18,58,109,215,164,3,0,},{216,204,129,38,62,133,13,},
{206,164,112,206,16,5,0,},},{{17,254,109,40,174,3,0,},{238,136,121,21,114,8,14,},{208,84,108,44,118,6,0,},{206,232,88,212,160,5,0,},},{{34,33,113,215,96,8,0,},
{216,212,65,5,82,5,0,},{207,40,112,213,132,2,0,},},{{8,82,96,209,0,0,0,},{217,156,64,220,0,8,0,},},{{224,188,65,226,80,5,0,},{221,32,108,213,168,7,0,},},
{{19,150,113,238,188,3,0,},{4,222,69,5,150,8,0,},{208,8,112,8,66,7,0,},},{{20,194,4,211,0,0,0,},{220,136,120,21,238,101,13,},{210,28,112,213,164,6,0,},},
{{16,190,109,224,164,3,0,},{215,44,65,3,82,5,0,},{207,80,104,207,136,3,0,},},{{5,2,74,5,30,6,0,},{216,236,129,38,62,133,13,},{213,64,72,218,120,5,0,},},
{{53,50,77,52,2,0,0,},{4,206,69,5,150,8,0,},{34,41,73,3,162,8,0,},{210,64,64,218,228,6,0,},},{{220,92,120,21,238,101,13,},{216,236,121,21,42,133,13,},
{207,48,104,207,136,3,0,},},{{12,94,108,207,164,3,0,},{215,60,65,3,82,5,0,},{210,88,128,38,210,86,13,},},{{22,58,77,34,9,0,0,},{217,136,128,38,246,103,13,},
{217,108,64,220,0,8,0,},{215,40,125,13,142,53,32,},},{{224,148,125,13,142,37,14,},{212,216,112,206,220,5,0,},},{{214,136,68,220,100,5,0,},{206,192,108,206,200,4,0,},},
{{5,206,73,5,30,6,0,},{213,28,120,21,42,85,13,},{212,180,128,38,250,229,12,},},{{212,196,72,212,28,6,0,},{209,16,105,207,208,1,0,},},{{238,160,113,224,96,8,0,},
{214,128,112,214,16,5,0,},{210,52,120,21,190,86,13,},},{{4,26,109,216,48,8,0,},{226,196,65,226,4,6,0,},{214,92,112,214,16,5,0,},},{{8,18,97,209,0,0,0,},
{213,88,124,13,142,165,13,},{213,36,112,213,16,5,0,},},{{3,62,109,215,172,5,0,},{238,152,113,224,96,8,0,},{206,196,64,212,80,5,0,},},{{20,234,4,211,0,0,0,},
{3,122,109,215,172,5,0,},{206,176,112,206,16,5,0,},},{{4,238,121,21,114,136,13,},{216,220,129,38,62,133,13,},{208,52,112,213,164,6,0,},},{{221,36,64,218,0,8,0,},
{207,64,124,13,26,163,13,},{207,28,112,213,132,2,0,},},{{5,230,125,13,42,86,32,},{215,64,65,3,82,5,0,},{211,172,108,206,168,7,0,},},{{226,156,109,224,172,5,0,},
{216,200,129,38,62,133,13,},{208,64,72,218,12,7,0,},},{{32,202,45,17,2,0,0,},{210,80,108,213,92,6,0,},},{{3,46,129,38,250,117,13,},{218,64,120,21,238,85,13,},},
{{215,80,65,3,82,5,0,},{209,64,128,38,242,80,13,},},{{22,42,77,34,9,0,0,},{224,168,113,224,16,5,0,},},{{43,238,4,25,2,0,0,},{238,132,121,21,114,8,14,},
{224,140,121,21,42,5,14,},{212,232,108,206,172,5,0,},},{{23,106,117,53,154,7,0,},{220,104,120,21,238,101,13,},{207,36,104,207,136,3,0,},},{{13,110,85,23,2,0,0,},
{221,28,68,218,12,8,0,},{211,192,112,206,216,7,0,},},{{45,18,253,45,2,0,13,},{221,88,68,218,12,8,0,},{211,228,120,21,234,231,12,},},{{17,222,109,216,164,3,0,},
{214,156,112,214,16,5,0,},{214,104,128,38,62,101,13,},{208,88,124,13,34,167,13,},},{{34,121,125,13,174,56,32,},{212,212,68,212,16,6,0,},{210,68,108,213,92,6,0,},},
{{220,108,120,21,238,101,13,},{214,120,124,13,142,197,13,},{213,68,108,213,200,4,0,},},{{217,116,120,21,234,103,13,},{210,28,104,207,104,7,0,},},{{220,152,108,41,190,5,0,},
{207,64,68,218,232,2,0,},},{{207,52,120,21,162,82,13,},},{{218,56,108,213,172,5,0,},{215,128,109,215,200,4,0,},{213,24,112,213,16,5,0,},},{{5,210,109,216,172,5,0,},
{211,244,128,38,246,231,12,},{206,208,64,212,80,5,0,},},{{4,230,125,13,174,88,32,},{220,132,128,38,250,101,13,},{210,40,68,218,248,6,0,},},{{4,250,121,21,114,136,13,},
{34,53,125,13,174,56,32,},{210,32,120,21,190,86,13,},{208,32,112,213,164,6,0,},},{{3,66,129,38,250,117,13,},{213,32,120,21,42,85,13,},},{{213,40,68,218,100,5,0,},
{209,48,108,213,84,0,0,},},{{3,58,65,3,6,6,0,},{224,152,109,224,200,4,0,},},{{4,226,113,216,96,8,0,},{210,56,112,213,164,6,0,},},{{34,69,129,38,126,120,13,},
{224,136,69,226,100,5,0,},{206,200,64,212,80,5,0,},},{{5,226,125,13,42,86,32,},{217,92,128,38,246,103,13,},},{{238,188,113,224,96,8,0,},{238,160,73,226,160,8,0,},
{216,24,121,21,42,133,13,},},{{34,69,109,215,48,8,0,},{210,48,104,207,104,7,0,},},{{3,34,129,38,250,117,13,},{218,68,112,213,220,5,0,},{209,32,72,218,68,1,0,},},
{{34,81,65,3,138,8,0,},{211,212,112,206,216,7,0,},},{{226,152,69,226,16,6,0,},{224,172,73,226,120,5,0,},{206,164,120,21,42,229,12,},},{{238,136,113,224,96,8,0,},
{214,116,120,21,42,101,13,},},{{4,214,73,5,162,8,0,},{214,148,120,21,42,101,13,},{207,32,128,38,186,82,13,},},{{4,222,125,13,174,88,32,},{209,80,124,13,98,161,13,},},
{{226,168,69,226,16,6,0,},{224,188,73,226,120,5,0,},},{{11,90,100,207,0,0,0,},{209,24,108,213,84,0,0,},},{{214,124,88,220,160,5,0,},{207,56,104,207,136,3,0,},},
{{215,44,89,3,162,5,0,},{210,252,255,208,4,0,13,},},{{5,2,66,5,6,6,0,},{5,238,125,13,42,86,32,},{213,64,64,218,80,5,0,},},{{224,140,125,13,142,37,14,},
{218,48,124,13,42,166,13,},{210,64,72,218,12,7,0,},},{{218,36,64,218,4,6,0,},{216,228,121,21,42,133,13,},{207,48,112,213,132,2,0,},},{{34,33,129,38,126,120,13,},
{215,60,121,21,42,117,13,},{212,208,72,212,28,6,0,},},{{221,36,68,218,12,8,0,},{217,120,120,21,234,103,13,},},{{212,216,120,21,238,229,12,},{206,212,108,206,200,4,0,},},
{{218,52,64,218,4,6,0,},{210,36,112,213,164,6,0,},{208,36,120,21,190,86,13,},},{{215,120,125,13,142,53,32,},{213,80,124,13,142,165,13,},},{{221,52,68,218,12,8,0,},
{211,232,112,206,216,7,0,},{209,12,108,11,170,1,0,},},{{212,192,112,206,220,5,0,},{210,0,105,207,104,7,0,},},{{4,230,121,21,114,136,13,},{212,188,64,212,4,6,0,},
{210,60,120,21,190,86,13,},},{{4,2,122,21,114,136,13,},{221,52,72,218,24,8,0,},{209,52,72,218,68,1,0,},},{{4,230,129,38,126,136,13,},{210,60,128,38,210,86,13,},
{206,196,72,212,120,5,0,},},{{14,82,108,213,164,3,0,},{211,172,128,38,246,231,12,},{206,176,120,21,42,229,12,},},{{4,238,65,5,138,8,0,},{208,52,72,218,12,7,0,},},
{{218,28,124,13,42,166,13,},{207,28,104,207,136,3,0,},},{{3,54,125,13,42,54,32,},{215,64,73,3,122,5,0,},{213,52,68,218,100,5,0,},},{{34,65,73,3,162,8,0,},
{208,64,64,218,228,6,0,},{206,244,124,13,142,69,13,},},{{23,86,69,49,142,7,0,},{238,140,121,21,114,8,14,},{215,80,113,215,16,5,0,},{212,224,108,206,172,5,0,},},
{{218,64,64,218,4,6,0,},{213,60,112,213,16,5,0,},},{{16,170,109,224,164,3,0,},{220,148,68,220,16,6,0,},{215,80,73,3,122,5,0,},{213,60,120,21,42,85,13,},},
{{15,130,108,214,164,3,0,},{226,148,125,13,42,38,14,},{224,168,121,21,42,5,14,},},{{19,146,113,238,188,3,0,},{17,214,109,216,164,3,0,},{4,210,109,216,48,8,0,},
{207,80,64,218,208,2,0,},},{{218,80,64,218,4,6,0,},{207,36,112,213,132,2,0,},},{{216,20,49,45,198,3,0,},{211,192,120,21,234,231,12,},{209,204,108,20,54,0,0,},},
{{22,70,77,34,9,0,0,},},{{215,76,121,21,42,117,13,},},{{27,6,113,27,174,3,0,},{12,38,108,207,164,3,0,},{207,60,120,21,162,82,13,},},{{30,102,40,15,2,0,0,},
{4,226,73,5,162,8,0,},},{{20,246,4,211,0,0,0,},{3,82,109,215,172,5,0,},{217,156,120,21,234,103,13,},{210,24,128,38,210,86,13,},},{{224,196,121,21,42,5,14,},
{211,176,128,38,246,231,12,},{209,64,64,218,12,1,0,},},{{34,121,73,3,162,8,0,},{220,148,108,214,172,5,0,},{218,32,112,213,220,5,0,},},{{220,156,72,220,28,6,0,},
{213,24,120,21,42,85,13,},},{{5,202,121,21,238,133,13,},{3,66,109,215,172,5,0,},{206,208,72,212,120,5,0,},},{{224,144,109,224,200,4,0,},{214,132,112,214,16,5,0,},
{212,196,120,21,238,229,12,},},{{210,32,64,218,228,6,0,},{208,32,72,218,12,7,0,},},{{221,48,128,38,246,87,13,},{213,32,112,213,16,5,0,},{210,64,68,218,248,6,0,},},
{{221,56,124,13,38,168,13,},{211,176,108,206,168,7,0,},{210,56,128,38,210,86,13,},},{{34,129,69,3,150,8,0,},{226,136,109,224,172,5,0,},{206,180,112,206,16,5,0,},},
{{36,46,108,6,246,1,0,},{34,77,109,215,48,8,0,},{210,56,104,207,104,7,0,},},{{224,196,65,226,80,5,0,},{207,24,112,213,132,2,0,},},{{5,238,129,38,250,133,13,},
{221,56,128,38,246,87,13,},},{{48,22,81,45,10,0,0,},{224,156,73,226,120,5,0,},{206,172,120,21,42,229,12,},},{{207,68,64,218,208,2,0,},},{{218,68,120,21,238,85,13,},
{215,68,109,215,200,4,0,},{209,32,64,218,12,1,0,},},{{8,34,96,209,0,0,0,},{209,12,105,207,208,1,0,},{209,40,124,13,98,161,13,},},{{226,152,125,13,42,38,14,},
{224,172,113,224,16,5,0,},},{{9,34,92,207,0,0,0,},{8,2,97,209,0,0,0,},{226,144,65,226,4,6,0,},{206,232,72,212,120,5,0,},},{{4,214,65,5,138,8,0,},
{215,80,89,3,162,5,0,},{214,104,108,214,200,4,0,},},{{5,250,109,216,172,5,0,},{221,24,108,213,168,7,0,},{218,68,128,38,250,85,13,},},{{6,66,4,221,0,0,0,},
{221,84,108,44,186,7,0,},{220,136,124,13,42,198,13,},{206,224,68,212,100,5,0,},},{{26,158,44,15,2,0,0,},{23,34,117,48,126,7,0,},{211,212,120,21,234,231,12,},},
{{12,58,108,207,164,3,0,},{216,228,113,216,16,5,0,},{210,28,64,218,228,6,0,},},{{215,128,129,38,62,117,13,},{209,88,108,213,84,0,0,},},{{4,206,129,38,126,136,13,},
{238,196,65,226,136,8,0,},{217,112,120,21,234,103,13,},},{{212,208,120,21,238,229,12,},{206,220,108,206,200,4,0,},},{{218,36,72,218,28,6,0,},{216,24,109,216,200,4,0,},
{207,48,120,21,162,82,13,},},{{215,60,113,215,16,5,0,},{209,28,104,207,208,1,0,},},{{217,128,120,21,234,103,13,},{211,224,112,206,216,7,0,},},{{35,94,8,36,10,0,0,},
{238,168,121,21,114,8,14,},{214,108,108,214,200,4,0,},{209,28,128,38,242,80,13,},},{{218,52,72,218,28,6,0,},{210,36,120,21,190,86,13,},{208,36,112,213,164,6,0,},},
{{5,214,129,38,250,133,13,},{221,52,128,38,246,87,13,},{214,124,124,13,142,197,13,},},{{5,214,125,13,42,86,32,},{221,52,124,13,38,168,13,},{211,232,72,212,24,8,0,},},
{{215,120,89,3,162,5,0,},{212,180,108,206,172,5,0,},{210,80,128,38,210,86,13,},},{{4,230,113,216,96,8,0,},{226,140,65,226,4,6,0,},{210,60,112,213,164,6,0,},
{209,88,124,13,98,161,13,},},{{209,52,64,218,12,1,0,},{209,40,128,38,242,80,13,},},{{3,130,113,215,220,5,0,},{3,62,125,13,42,54,32,},{211,252,120,21,234,231,12,},},
{{209,60,128,38,242,80,13,},{206,252,124,13,142,69,13,},},{{4,238,73,5,162,8,0,},{210,52,72,218,12,7,0,},{208,52,64,218,228,6,0,},},{{214,132,72,220,120,5,0,},
{207,64,108,213,48,2,0,},},{{16,162,109,224,164,3,0,},{4,234,129,38,126,136,13,},{209,36,124,13,98,161,13,},},{{15,138,108,214,164,3,0,},{3,66,125,13,42,54,32,},
{226,156,125,13,42,38,14,},{224,160,121,21,42,5,14,},},{{238,140,113,224,96,8,0,},},{{6,122,4,217,0,0,0,},{218,64,72,218,28,6,0,},{207,88,68,218,232,2,0,},},
{{4,206,125,13,174,88,32,},{215,64,69,3,102,5,0,},{211,200,120,21,234,231,12,},},{{15,154,108,41,174,3,0,},{34,69,125,13,174,56,32,},{224,168,129,38,62,5,14,},},
{{34,81,125,13,174,56,32,},{211,200,128,38,246,231,12,},{207,80,72,218,0,3,0,},},{{19,170,113,238,188,3,0,},{218,80,72,218,28,6,0,},{207,36,120,21,162,82,13,},},
{{221,88,128,38,246,87,13,},{215,40,89,3,162,5,0,},{211,192,64,212,0,8,0,},},{{217,148,120,21,234,103,13,},{214,120,112,214,16,5,0,},},{{19,138,113,238,188,3,0,},
{11,14,101,207,0,0,0,},{208,88,108,213,92,6,0,},},{{14,38,108,213,164,3,0,},{210,16,105,207,104,7,0,},{207,60,112,213,132,2,0,},},{{12,2,109,207,164,3,0,},
{215,32,129,38,62,117,13,},{213,68,124,13,142,165,13,},},{{226,188,109,224,172,5,0,},{217,116,72,220,24,8,0,},},{{224,196,113,224,16,5,0,},{214,112,108,214,200,4,0,},
{206,216,68,212,100,5,0,},},{{34,121,65,3,138,8,0,},{218,32,120,21,238,85,13,},{207,52,104,207,136,3,0,},},{{211,252,108,206,168,7,0,},{209,0,104,207,208,1,0,},},
{{221,48,124,13,38,168,13,},{217,100,72,220,24,8,0,},{211,184,108,206,168,7,0,},},{{214,104,68,220,100,5,0,},{212,196,112,206,220,5,0,},{206,216,128,38,62,229,12,},},
{{4,250,73,5,162,8,0,},{216,248,121,21,42,133,13,},{210,32,72,218,12,7,0,},{208,32,64,218,228,6,0,},},{{218,48,68,218,16,6,0,},{213,84,108,44,226,4,0,},
{209,8,112,8,146,1,0,},},{{34,129,129,38,126,120,13,},{217,108,112,214,216,7,0,},{206,200,68,212,100,5,0,},},{{212,184,108,206,172,5,0,},{206,180,120,21,42,229,12,},},
{{238,188,109,224,48,8,0,},},{{34,65,129,38,126,120,13,},{215,76,109,215,200,4,0,},},{{238,140,129,38,126,8,14,},{209,56,68,218,40,1,0,},{209,40,104,207,208,1,0,},},
{{224,172,69,226,100,5,0,},{206,172,112,206,16,5,0,},},{{34,81,69,3,150,8,0,},{207,68,72,218,0,3,0,},},{{218,24,108,213,172,5,0,},{216,0,126,13,142,85,32,},
{213,56,112,213,16,5,0,},},{{38,142,61,19,2,0,0,},{211,212,64,212,0,8,0,},{208,0,113,7,114,7,0,},},{{20,210,4,211,0,0,0,},{224,172,121,21,42,5,14,},
{207,68,108,213,48,2,0,},},{{19,158,113,238,188,3,0,},{226,144,73,226,28,6,0,},{206,232,64,212,80,5,0,},},{{12,50,108,207,164,3,0,},{207,32,112,213,132,2,0,},},
{{209,80,108,213,84,0,0,},},{{8,90,96,209,0,0,0,},{209,56,128,38,242,80,13,},},{{220,108,108,214,172,5,0,},{216,220,109,216,200,4,0,},{207,4,105,207,136,3,0,},},
{{207,56,120,21,162,82,13,},},{{213,64,124,13,142,165,13,},{213,28,88,218,160,5,0,},{209,64,108,213,84,0,0,},},{{226,160,109,224,172,5,0,},{217,112,112,214,216,7,0,},
{216,248,69,5,102,5,0,},},{{224,140,109,224,200,4,0,},{208,52,128,38,210,86,13,},},{{8,30,96,209,0,0,0,},{218,36,112,213,220,5,0,},{207,48,64,218,208,2,0,},},
{{220,124,112,214,220,5,0,},{209,28,112,213,180,0,0,},},{{217,128,112,214,216,7,0,},{212,192,128,38,250,229,12,},},{{34,117,109,34,82,8,0,},{238,168,113,224,96,8,0,},
{210,48,128,38,210,86,13,},},{{34,57,109,215,48,8,0,},{213,80,128,38,62,85,13,},{208,36,104,207,104,7,0,},},{{16,150,109,224,164,3,0,},{16,138,109,224,164,3,0,},
{238,168,69,226,148,8,0,},},{{18,66,109,215,164,3,0,},{3,70,125,13,42,54,32,},{211,232,64,212,0,8,0,},{211,188,68,212,12,8,0,},},{{4,2,126,13,174,88,32,},
{34,57,129,38,126,120,13,},{214,100,124,13,142,197,13,},},{{213,88,64,218,80,5,0,},{211,224,128,38,246,231,12,},{207,12,108,11,86,3,0,},},{{5,250,129,38,250,133,13,},
{212,212,72,212,28,6,0,},},{{7,2,104,207,0,0,0,},{3,130,121,21,238,117,13,},{221,60,108,213,168,7,0,},{206,196,88,212,160,5,0,},},{{217,116,124,13,38,200,13,},},
{{13,82,85,34,1,0,0,},{4,202,73,5,162,8,0,},{238,156,73,226,160,8,0,},},{{5,230,73,5,30,6,0,},{3,54,65,3,6,6,0,},{213,52,120,21,42,85,13,},},
{{5,238,109,216,172,5,0,},{214,104,72,220,120,5,0,},{211,208,120,21,234,231,12,},},{{4,2,66,5,138,8,0,},{224,160,113,224,16,5,0,},{206,244,108,206,200,4,0,},},
{{19,190,113,238,188,3,0,},{238,140,73,226,160,8,0,},{216,0,130,38,62,133,13,},{212,172,128,38,250,229,12,},},{{14,62,108,213,164,3,0,},{3,82,65,3,6,6,0,},
{211,164,128,38,246,231,12,},},{{40,242,5,37,2,0,0,},{218,88,68,218,16,6,0,},{209,44,108,6,30,0,0,},{209,32,68,218,40,1,0,},},{{15,114,108,214,164,3,0,},
{4,222,129,38,126,136,13,},{206,228,108,206,200,4,0,},},{{28,66,44,14,2,0,0,},{9,230,92,207,0,0,0,},{4,210,125,13,174,88,32,},{208,80,108,213,92,6,0,},},
{{218,80,112,213,220,5,0,},{207,36,64,218,208,2,0,},},{{14,34,108,213,164,3,0,},{221,28,124,13,38,168,13,},{211,192,72,212,24,8,0,},},{{238,156,129,38,126,8,14,},
{217,148,112,214,216,7,0,},},{{10,174,108,206,164,3,0,},{214,120,108,214,200,4,0,},{212,212,120,21,238,229,12,},},{{218,40,120,21,238,85,13,},{215,56,121,21,42,117,13,},},
{{8,6,97,209,0,0,0,},{213,56,88,218,160,5,0,},{209,68,68,218,40,1,0,},},{{217,116,64,220,0,8,0,},{214,120,128,38,62,101,13,},{211,208,112,206,216,7,0,},},
{{238,172,121,21,114,8,14,},},{{9,18,93,207,0,0,0,},{218,32,128,38,250,85,13,},{213,88,68,218,100,5,0,},},{{34,61,69,3,150,8,0,},{238,172,129,38,126,8,14,},},
{{221,32,128,38,246,87,13,},{217,100,64,220,0,8,0,},{206,208,88,212,160,5,0,},},{{34,53,129,38,126,120,13,},{210,4,113,27,94,7,0,},{210,40,108,213,92,6,0,},},
{{220,132,124,13,42,198,13,},{214,100,108,214,200,4,0,},},{{211,244,124,13,38,72,13,},{211,184,128,38,246,231,12,},},{{217,108,120,21,234,103,13,},{210,76,108,28,142,6,0,},},
{{226,136,125,13,42,38,14,},{220,92,128,38,250,101,13,},{212,244,72,212,28,6,0,},},{{21,202,53,4,2,0,0,},{238,144,65,226,136,8,0,},},{{30,134,40,15,2,0,0,},
{220,100,120,21,238,101,13,},},{{0}},{{238,152,109,224,48,8,0,},{215,64,121,21,42,117,13,},{212,252,112,206,220,5,0,},},{{34,33,121,21,114,120,13,},{220,124,68,220,16,6,0,},
{216,204,69,5,102,5,0,},},{{217,156,72,220,24,8,0,},{215,68,125,13,142,53,32,},{213,56,120,21,42,85,13,},},{{3,34,109,215,172,5,0,},{216,244,109,32,250,4,0,},
{211,212,72,212,24,8,0,},},{{226,152,109,224,172,5,0,},{212,228,120,21,238,229,12,},},{{4,214,125,13,174,88,32,},{216,212,109,216,200,4,0,},{207,12,105,207,136,3,0,},},
{{19,154,113,238,188,3,0,},{14,50,108,213,164,3,0,},{207,32,120,21,162,82,13,},},{{5,250,125,13,42,86,32,},{238,136,129,38,126,8,14,},{226,172,129,38,250,5,14,},},
{{238,148,69,226,148,8,0,},{226,168,109,224,172,5,0,},},{{41,142,4,30,2,0,0,},{207,4,113,27,102,3,0,},},{{214,124,64,220,80,5,0,},{207,56,112,213,132,2,0,},},
{{217,108,72,220,24,8,0,},},{{37,2,42,17,2,0,0,},{224,28,113,46,186,4,0,},{214,116,128,38,62,101,13,},},{{34,125,109,51,66,8,0,},{226,160,129,38,250,5,14,},
{208,24,112,213,164,6,0,},},{{218,36,120,21,238,85,13,},{211,224,124,13,38,72,13,},{207,48,72,218,0,3,0,},},{{10,166,108,206,164,3,0,},{238,168,129,38,126,8,14,},
{214,136,128,38,62,101,13,},{209,28,120,21,214,80,13,},},{{224,148,73,226,120,5,0,},{212,216,68,212,16,6,0,},{210,52,64,218,228,6,0,},},{{226,196,73,226,28,6,0,},
{214,108,124,13,142,197,13,},{210,88,72,218,12,7,0,},},{{210,36,104,207,104,7,0,},{209,252,255,208,16,0,13,},},{{7,230,104,207,0,0,0,},{5,26,109,216,172,5,0,},
{211,188,128,38,246,231,12,},{209,4,112,9,126,1,0,},},{{5,214,109,216,172,5,0,},{221,52,108,213,168,7,0,},{217,104,112,214,216,7,0,},},{{226,140,125,13,42,38,14,},
{212,200,112,206,220,5,0,},},{{4,250,65,5,138,8,0,},{213,36,68,218,100,5,0,},},{{10,210,108,206,164,3,0,},},{{3,130,65,3,6,6,0,},{206,184,108,206,200,4,0,},},
{{15,106,108,214,164,3,0,},{220,132,72,220,28,6,0,},{206,252,108,206,200,4,0,},},{{3,66,121,21,238,117,13,},{238,156,65,226,136,8,0,},{220,136,108,214,172,5,0,},},
{{5,230,65,5,6,6,0,},{3,54,73,3,30,6,0,},{215,64,125,13,142,53,32,},{213,52,112,213,16,5,0,},},{{221,64,72,218,24,8,0,},{209,36,108,213,84,0,0,},},
{{224,160,73,226,120,5,0,},{221,80,128,38,246,87,13,},{208,64,104,207,104,7,0,},},{{226,156,129,38,250,5,14,},{216,200,109,216,200,4,0,},{208,4,112,9,54,7,0,},},
{{5,210,125,13,42,86,32,},{209,36,128,38,242,80,13,},},{{238,132,129,38,126,8,14,},{226,148,65,226,4,6,0,},{224,168,69,226,100,5,0,},},{{26,102,44,15,2,0,0,},
{212,232,64,212,4,6,0,},{206,160,128,38,62,229,12,},},{{34,81,109,215,48,8,0,},{216,208,69,5,102,5,0,},{210,48,108,213,92,6,0,},},{{20,198,4,211,0,0,0,},
{220,108,128,38,250,101,13,},{218,80,120,21,238,85,13,},{207,36,72,218,0,3,0,},},{{221,80,120,21,234,87,13,},{215,40,73,3,122,5,0,},{208,64,68,218,248,6,0,},},
{{16,146,109,224,164,3,0,},{14,90,108,213,164,3,0,},{4,210,113,216,96,8,0,},},{{226,188,129,38,250,5,14,},{212,212,112,206,220,5,0,},{208,28,104,207,104,7,0,},},
{{218,40,112,213,220,5,0,},{208,80,120,21,190,86,13,},},{{215,56,73,3,122,5,0,},{215,52,109,215,200,4,0,},{209,24,112,213,180,0,0,},},{{22,62,77,34,9,0,0,},
{3,82,69,3,18,6,0,},{226,188,125,13,42,38,14,},{213,64,120,21,42,85,13,},},{{238,172,113,224,96,8,0,},{217,132,68,220,12,8,0,},{214,112,124,13,142,197,13,},},
{{220,156,124,13,42,198,13,},{216,212,129,38,62,133,13,},},{{5,202,65,5,6,6,0,},{221,40,64,218,0,8,0,},{212,220,128,38,250,229,12,},{211,252,124,13,38,72,13,},},
{{3,66,69,3,18,6,0,},{217,100,120,21,234,103,13,},{212,212,108,206,172,5,0,},},{{212,196,64,212,4,6,0,},{206,200,120,21,42,229,12,},},{{17,26,109,216,164,3,0,},
{224,144,129,38,62,5,14,},{208,68,64,218,228,6,0,},},{{221,56,64,218,0,8,0,},{213,40,112,213,16,5,0,},},{{9,66,92,207,0,0,0,},{3,58,109,215,172,5,0,},
{224,152,65,226,80,5,0,},{206,200,72,212,120,5,0,},},{{34,45,73,3,162,8,0,},{206,188,128,38,62,229,12,},},{{224,172,65,226,80,5,0,},{211,196,68,212,12,8,0,},},
{{27,14,108,11,166,3,0,},{34,81,73,3,162,8,0,},{213,48,120,21,42,85,13,},{212,252,128,38,250,229,12,},},{{6,38,4,221,0,0,0,},{3,42,109,215,172,5,0,},
{221,48,108,213,168,7,0,},},{{213,48,128,38,62,85,13,},{212,252,120,21,238,229,12,},},{{226,152,129,38,250,5,14,},{208,76,108,28,142,6,0,},{208,56,104,207,104,7,0,},},
{{215,68,69,3,102,5,0,},{213,56,64,218,80,5,0,},{209,32,104,207,208,1,0,},},{{221,68,120,21,234,87,13,},{215,128,69,3,102,5,0,},{212,224,128,38,250,229,12,},},
};

struct action_table_key {
    uint8_t bytes[3];
};
static inline struct action_table_key encode_key(uint32_t target_nfa_state, uint32_t dfa_state, uint32_t dfa_symbol) {
    struct action_table_key key = {{0}};
    key.bytes[0] |= (target_nfa_state >> 0) & 255;
    key.bytes[1] |= (target_nfa_state >> 8) & 3;
    key.bytes[1] |= (dfa_state << 2) & 255;
    key.bytes[2] |= (dfa_state >> 6) & 3;
    key.bytes[2] |= (dfa_symbol << 2) & 255;
    return key;
}
struct action_table_entry {
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static struct action_table_entry decode_entry(const uint8_t *bytes) {
    struct action_table_entry entry = {0};
    entry.nfa_state |= ((uint32_t)bytes[3] & 255) << 0;
    entry.nfa_state |= ((uint32_t)bytes[4] & 3) << 8;
    entry.actions |= ((uint32_t)bytes[4] & 255) >> 2;
    entry.actions |= ((uint32_t)bytes[5] & 15) << 6;
    entry.push_nfa_state |= ((uint32_t)bytes[5] & 255) >> 4;
    entry.push_nfa_state |= ((uint32_t)bytes[6] & 63) << 4;
    return entry;
}
static struct action_table_entry action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t hash = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5);
    uint32_t index1 = hash & 1023;
    uint32_t index2 = hash >> 22;
    struct action_table_key key = encode_key(nfa_state, dfa_state, token);
    uint32_t j = 0;
    const uint8_t *entry = 0;
    for (; j < 4; ++j) {
        entry = action_table[index1][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
        entry = action_table[index2][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
    }
    if (j >= 4)
        abort();
    return decode_entry(entry);
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    uint32_t i;
    for (i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, struct owl_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 210;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        uint16_t i;
        for (i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            struct action_table_entry entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (run->tokens[i] < 30)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry.push_nfa_state;
            }
            apply_actions(&construct_state, entry.actions, end, end + whitespace);
            if (run->states[i] == 69) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry.nfa_state;
            whitespace = end - offset - len;
        }
        struct owl_token_run *old = run;
        run = run->prev;
        free(old);
    }
    struct action_table_entry entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    apply_actions(&construct_state, entry.actions, offset, offset + whitespace);
    free(state_stack);
    free_token_runs(&run);
    return construct_finish(&construct_state, offset);
}
static size_t read_whitespace(const char *text, void *info) {
    switch (text[0]) {
    case 32:
        return 1;
    case 9:
        return 1;
    case 10:
        return 1;
    case 13:
        return 1;
    default:
        return 0;
    }
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 44:
        *end_token = false;
        *token = 19;
        return 1;
    case 46:
        switch (text[1]) {
        case 108:
            if (text[2] == 105 && text[3] == 110 && text[4] == 101 && text[5] == 45 && text[6] == 99 && text[7] == 111 && text[8] == 109 && text[9] == 109 && text[10] == 101 && text[11] == 110 && text[12] == 116 && text[13] == 45 && text[14] == 116 && text[15] == 111 && text[16] == 107 && text[17] == 101 && text[18] == 110) {
                *end_token = false;
                *token = 23;
                return 19;
            } else {
                return 0;
            }
        case 111:
            if (text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
                *end_token = false;
                *token = 2;
                return 10;
            } else {
                return 0;
            }
        case 116:
            if (text[2] == 111 && text[3] == 107 && text[4] == 101 && text[5] == 110) {
                *end_token = false;
                *token = 25;
                return 6;
            } else {
                return 0;
            }
        case 119:
            if (text[2] == 104 && text[3] == 105 && text[4] == 116 && text[5] == 101 && text[6] == 115 && text[7] == 112 && text[8] == 97 && text[9] == 99 && text[10] == 101) {
                *end_token = false;
                *token = 26;
                return 11;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 1;
        return 1;
    case 61:
        *end_token = false;
        *token = 0;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 92:
        *end_token = false;
        *token = 10;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 6;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 5;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 7;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 24;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 9;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 3;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 4;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 8;
            return 5;
        } else {
            return 0;
        }
    case 123:
        *end_token = false;
        *token = 20;
        return 1;
    case 124:
        *end_token = false;
        *token = 22;
        return 1;
    case 125:
        *end_token = true;
        *token = 21;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 9;
        case 2: return 11;
        case 3: return 12;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 13;
        case 1: return 2;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 7;
        case 1: return 13;
        case 2: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 4;
        case 1: return 6;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 5;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        case 1: return 13;
        default: break;
        }
        break;
    case 7:
        switch (slot) {
        case 0: return 13;
        case 1: return 13;
        case 2: return 13;
        case 3: return 14;
        case 4: return 7;
        case 5: return 14;
        case 6: return 14;
        case 7: return 8;
        case 8: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 15;
        case 1: return 15;
        default: break;
        }
        break;
    case 9:
        switch (slot) {
        case 0: return 14;
        case 1: return 10;
        default: break;
        }
        break;
    case 10:
        switch (slot) {
        case 0: return 14;
        default: break;
        }
        break;
    case 11:
        switch (slot) {
        case 0: return 13;
        case 1: return 14;
        default: break;
        }
        break;
    case 12:
        switch (slot) {
        case 0: return 14;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 7:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 8:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 9:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 4;
    case 1: return 2;
    case 2: return 3;
    case 3: return 2;
    case 4: return 1;
    case 5: return 0;
    case 6: return 2;
    case 7: return 9;
    case 8: return 2;
    case 9: return 2;
    case 10: return 1;
    case 11: return 2;
    case 12: return 1;
    case 13: return 0;
    case 14: return 0;
    case 15: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 8;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 12:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 13:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 14:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 15:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

